"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const ConsoleErrHandler_1 = __importDefault(require("./handlers/ConsoleErrHandler"));
const utils = __importStar(require("./utils"));
class Logger {
    key;
    level;
    filter;
    keys;
    handlers;
    parent;
    _loggers = new Map();
    loggersRegistry;
    constructor(key = 'root', level = types_1.LogLevel.NOTSET, handlers = [new ConsoleErrHandler_1.default()], parent) {
        this.key = key;
        this.level = level;
        this.handlers = new Set(handlers);
        this.parent = parent;
        this.keys = parent != null ? `${parent.keys}.${key}` : key;
        this.loggersRegistry = new FinalizationRegistry((key) => {
            this._loggers.delete(key);
        });
    }
    get loggers() {
        return new Map([...this._loggers.entries()]
            .map(([key, loggerRef]) => {
            const logger = loggerRef.deref();
            if (logger != null) {
                return [key, logger];
            }
            else {
                return undefined;
            }
        })
            .filter((e) => e != null));
    }
    getChild(key) {
        let loggerRef = this._loggers.get(key);
        let logger = loggerRef?.deref();
        if (logger != null)
            return logger;
        logger = new Logger(key, types_1.LogLevel.NOTSET, [], this);
        loggerRef = new WeakRef(logger);
        this._loggers.set(key, loggerRef);
        this.loggersRegistry.register(logger, key);
        return logger;
    }
    getParent() {
        return this.parent;
    }
    setLevel(level) {
        this.level = level;
    }
    getEffectiveLevel() {
        if (this.level !== types_1.LogLevel.NOTSET) {
            return this.level;
        }
        if (this.parent) {
            return this.parent.getEffectiveLevel();
        }
        return this.level;
    }
    isEnabledFor(level) {
        return level >= this.level;
    }
    addHandler(handler) {
        this.handlers.add(handler);
    }
    removeHandler(handler) {
        this.handlers.delete(handler);
    }
    clearHandlers() {
        this.handlers.clear();
    }
    hasHandlers() {
        if (this.handlers.size) {
            return true;
        }
        else {
            return this.parent?.hasHandlers() ?? false;
        }
    }
    setFilter(filter) {
        this.filter = filter;
    }
    unsetFilter() {
        delete this.filter;
    }
    debug(msg, formatOrData, format) {
        if (formatOrData == null || typeof formatOrData === 'function') {
            return this.log(msg, {}, types_1.LogLevel.DEBUG, formatOrData);
        }
        else {
            return this.log(msg, formatOrData, types_1.LogLevel.DEBUG, format);
        }
    }
    info(msg, formatOrData, format) {
        if (formatOrData == null || typeof formatOrData === 'function') {
            return this.log(msg, {}, types_1.LogLevel.INFO, formatOrData);
        }
        else {
            return this.log(msg, formatOrData, types_1.LogLevel.INFO, format);
        }
    }
    warn(msg, formatOrData, format) {
        if (formatOrData == null || typeof formatOrData === 'function') {
            return this.log(msg, {}, types_1.LogLevel.WARN, formatOrData);
        }
        else {
            return this.log(msg, formatOrData, types_1.LogLevel.WARN, format);
        }
    }
    error(msg, formatOrData, format) {
        if (formatOrData == null || typeof formatOrData === 'function') {
            return this.log(msg, {}, types_1.LogLevel.ERROR, formatOrData);
        }
        else {
            return this.log(msg, formatOrData, types_1.LogLevel.ERROR, format);
        }
    }
    log(msg, data, level, format) {
        // Filter on level before making a record
        if (level < this.getEffectiveLevel())
            return;
        const record = this.makeRecord(msg, data, level);
        this.callHandlers(record, level, format);
    }
    /**
     * Constructs a `LogRecord`
     * The `LogRecord` can contain lazy values via wrapping with a lambda
     * This improves performance as they are not evaluated unless needed during formatting
     */
    makeRecord(msg, data, level) {
        return {
            logger: this,
            key: this.key,
            keys: this.keys,
            level,
            msg: msg?.toString(),
            data,
            date: () => new Date(),
            stack: () => {
                let stack;
                if (utils.hasCaptureStackTrace && utils.hasStackTraceLimit) {
                    Error.stackTraceLimit++;
                    const error = {};
                    // @ts-ignore: protected `Logger.prototype.log`
                    Error.captureStackTrace(error, Logger.prototype.log);
                    Error.stackTraceLimit--;
                    stack = error.stack;
                    // Remove the stack title and the first stack line for `Logger.prototype.log`
                    stack = stack.slice(stack.indexOf('\n', stack.indexOf('\n') + 1) + 1);
                }
                else {
                    stack = new Error().stack ?? '';
                    stack = stack.slice(stack.indexOf('\n') + 1);
                }
                return stack;
            },
        };
    }
    callHandlers(record, level, format, keys = '') {
        // Filter on level before calling handlers
        // This is also called when traversing up the parent
        if (level < this.getEffectiveLevel())
            return;
        keys = `${this.key}.${keys}`;
        if (this.filter != null && !this.filter.test(keys))
            return;
        for (const handler of this.handlers) {
            handler.handle(record, format);
        }
        if (this.parent) {
            this.parent.callHandlers(record, level, format, keys);
        }
    }
}
exports.default = Logger;
//# sourceMappingURL=Logger.js.map