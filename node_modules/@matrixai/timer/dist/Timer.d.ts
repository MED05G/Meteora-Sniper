import type { PromiseCancellableController } from '@matrixai/async-cancellable';
import { PromiseCancellable } from '@matrixai/async-cancellable';
/**
 * Just like `setTimeout` or `setInterval`,
 * this will keep the NodeJS event loop alive
 */
declare class Timer<T = void> implements Pick<PromiseCancellable<T>, keyof PromiseCancellable<T>> {
    /**
     * Delay in milliseconds
     * This may be `Infinity`
     */
    protected _delay: number;
    /**
     * If it is lazy, the timer will not eagerly reject
     * on cancellation if the handler has started executing
     */
    readonly lazy: boolean;
    /**
     * Timestamp when this is constructed
     * Guaranteed to be weakly monotonic within the process lifetime
     * Compare this with `performance.now()` not `Date.now()`
     */
    readonly timestamp: Date;
    /**
     * Timestamp when this is scheduled to finish and execute the handler
     * Guaranteed to be weakly monotonic within the process lifetime
     * Compare this with `performance.now()` not `Date.now()`
     */
    protected _scheduled?: Date;
    /**
     * Handler to be executed
     */
    protected handler?: (signal: AbortSignal) => T | PromiseLike<T>;
    /**
     * Deconstructed promise
     */
    protected p: PromiseCancellable<T>;
    /**
     * Resolve deconstructed promise
     */
    protected resolveP: (value?: T) => void;
    /**
     * Reject deconstructed promise
     */
    protected rejectP: (reason?: any) => void;
    /**
     * Abort controller allows immediate cancellation
     */
    protected abortController: AbortController;
    /**
     * Internal timeout reference
     */
    protected timeoutRef?: ReturnType<typeof setTimeout>;
    /**
     * The status indicates when we have started settling or settled
     */
    protected _status: 'settling' | 'settled' | null;
    /**
     * Construct a Timer
     * By default `lazy` is false, which means it will eagerly reject
     * the timer, even if the handler has already started executing
     * If `lazy` is true, this will make the timer wait for the handler
     * to finish executing
     * Note that passing a custom controller does not stop the default behaviour
     */
    constructor(handler?: (signal: AbortSignal) => T | PromiseLike<T>, delay?: number, lazy?: boolean, controller?: PromiseCancellableController);
    constructor(opts?: {
        handler?: (signal: AbortSignal) => T | PromiseLike<T>;
        delay?: number;
        lazy?: boolean;
        controller?: PromiseCancellableController;
    });
    get [Symbol.toStringTag](): string;
    get status(): 'settling' | 'settled' | null;
    /**
     * Timestamp when this is scheduled to finish and execute the handler
     * Guaranteed to be weakly monotonic within the process lifetime
     * Compare this with `performance.now()` not `Date.now()`
     */
    get scheduled(): Date | undefined;
    /**
     * Delay in milliseconds
     * This may be `Infinity`
     */
    get delay(): number;
    /**
     * Gets the remaining time in milliseconds
     * This will return `Infinity` if `delay` is `Infinity`
     * This will return `0` if status is `settling` or `settled`
     */
    getTimeout(): number;
    /**
     * To remaining time as a string
     * This may return `'Infinity'` if `this.delay` is `Infinity`
     * This will return `'0'` if status is `settling` or `settled`
     */
    toString(): string;
    /**
     * To remaining time as a number
     * This may return `Infinity` if `this.delay` is `Infinity`
     * This will return `0` if status is `settling` or `settled`
     */
    valueOf(): number;
    /**
     * Cancels the timer
     * Unlike `PromiseCancellable`, canceling the timer will not result
     * in an unhandled promise rejection, all promise rejections are ignored
     */
    cancel(reason?: any): void;
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T, signal: AbortSignal) => TResult1 | PromiseLike<TResult1>) | undefined | null, onRejected?: ((reason: any, signal: AbortSignal) => TResult2 | PromiseLike<TResult2>) | undefined | null, controller?: PromiseCancellableController): PromiseCancellable<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any, signal: AbortSignal) => TResult | PromiseLike<TResult>) | undefined | null, controller?: PromiseCancellableController): PromiseCancellable<T | TResult>;
    finally(onFinally?: ((signal: AbortSignal) => void) | undefined | null, controller?: PromiseCancellableController): PromiseCancellable<T>;
    /**
     * Refreshes the timer to the original delay and updates the scheduled time.
     * If the timer has already ended this does nothing.
     */
    refresh(): void;
    /**
     * Resets the timer with a new delay and updates the scheduled time and delay.
     */
    reset(delay: number): void;
    protected fulfill(): Promise<void>;
    protected reject(reason?: any): Promise<void>;
}
export default Timer;
