"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const perf_hooks_1 = require("perf_hooks");
const async_cancellable_1 = require("@matrixai/async-cancellable");
const errors_1 = require("./errors");
/**
 * Just like `setTimeout` or `setInterval`,
 * this will keep the NodeJS event loop alive
 */
class Timer {
    /**
     * Delay in milliseconds
     * This may be `Infinity`
     */
    _delay;
    /**
     * If it is lazy, the timer will not eagerly reject
     * on cancellation if the handler has started executing
     */
    lazy;
    /**
     * Timestamp when this is constructed
     * Guaranteed to be weakly monotonic within the process lifetime
     * Compare this with `performance.now()` not `Date.now()`
     */
    timestamp;
    /**
     * Timestamp when this is scheduled to finish and execute the handler
     * Guaranteed to be weakly monotonic within the process lifetime
     * Compare this with `performance.now()` not `Date.now()`
     */
    _scheduled;
    /**
     * Handler to be executed
     */
    handler;
    /**
     * Deconstructed promise
     */
    p;
    /**
     * Resolve deconstructed promise
     */
    resolveP;
    /**
     * Reject deconstructed promise
     */
    rejectP;
    /**
     * Abort controller allows immediate cancellation
     */
    abortController;
    /**
     * Internal timeout reference
     */
    timeoutRef;
    /**
     * The status indicates when we have started settling or settled
     */
    _status = null;
    constructor(handlerOrOpts, delay = 0, lazy = false, controller) {
        let handler;
        if (typeof handlerOrOpts === 'function') {
            handler = handlerOrOpts;
        }
        else if (typeof handlerOrOpts === 'object' && handlerOrOpts !== null) {
            handler = handlerOrOpts.handler;
            delay = handlerOrOpts.delay ?? delay;
            lazy = handlerOrOpts.lazy ?? lazy;
            controller = handlerOrOpts.controller ?? controller;
        }
        // Coerce NaN to minimal delay of 0
        if (isNaN(delay)) {
            delay = 0;
        }
        else {
            // Clip to delay >= 0
            delay = Math.max(delay, 0);
            if (isFinite(delay)) {
                // Clip to delay <= 2147483647 (maximum timeout)
                // but only if delay is finite
                delay = Math.min(delay, 2 ** 31 - 1);
            }
        }
        this.handler = handler;
        this._delay = delay;
        this.lazy = lazy;
        let abortController;
        if (typeof controller === 'function') {
            abortController = new AbortController();
            controller(abortController.signal);
        }
        else if (controller != null) {
            abortController = controller;
        }
        else {
            abortController = new AbortController();
            abortController.signal.addEventListener('abort', () => void this.reject(abortController.signal.reason));
        }
        this.p = new async_cancellable_1.PromiseCancellable((resolve, reject) => {
            this.resolveP = resolve.bind(this.p);
            this.rejectP = reject.bind(this.p);
        }, abortController);
        this.abortController = abortController;
        // If the delay is Infinity, this promise will never resolve
        // it may still reject however
        if (isFinite(delay)) {
            this.timeoutRef = setTimeout(() => void this.fulfill(), delay);
            this.timestamp = new Date(perf_hooks_1.performance.timeOrigin + perf_hooks_1.performance.now());
            this._scheduled = new Date(this.timestamp.getTime() + delay);
        }
        else {
            // Infinite interval, make sure you are cancelling the `Timer`
            // otherwise you will keep the process alive
            this.timeoutRef = setInterval(() => { }, 2 ** 31 - 1);
            this.timestamp = new Date(perf_hooks_1.performance.timeOrigin + perf_hooks_1.performance.now());
        }
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    get status() {
        return this._status;
    }
    /**
     * Timestamp when this is scheduled to finish and execute the handler
     * Guaranteed to be weakly monotonic within the process lifetime
     * Compare this with `performance.now()` not `Date.now()`
     */
    get scheduled() {
        return this._scheduled;
    }
    /**
     * Delay in milliseconds
     * This may be `Infinity`
     */
    get delay() {
        return this._delay;
    }
    /**
     * Gets the remaining time in milliseconds
     * This will return `Infinity` if `delay` is `Infinity`
     * This will return `0` if status is `settling` or `settled`
     */
    getTimeout() {
        if (this._status !== null)
            return 0;
        if (this._scheduled == null)
            return Infinity;
        return Math.max(Math.trunc(this._scheduled.getTime() -
            (perf_hooks_1.performance.timeOrigin + perf_hooks_1.performance.now())), 0);
    }
    /**
     * To remaining time as a string
     * This may return `'Infinity'` if `this.delay` is `Infinity`
     * This will return `'0'` if status is `settling` or `settled`
     */
    toString() {
        return this.getTimeout().toString();
    }
    /**
     * To remaining time as a number
     * This may return `Infinity` if `this.delay` is `Infinity`
     * This will return `0` if status is `settling` or `settled`
     */
    valueOf() {
        return this.getTimeout();
    }
    /**
     * Cancels the timer
     * Unlike `PromiseCancellable`, canceling the timer will not result
     * in an unhandled promise rejection, all promise rejections are ignored
     */
    cancel(reason) {
        void this.p.catch(() => { });
        this.p.cancel(reason);
    }
    then(onFulfilled, onRejected, controller) {
        return this.p.then(onFulfilled, onRejected, controller);
    }
    catch(onRejected, controller) {
        return this.p.catch(onRejected, controller);
    }
    finally(onFinally, controller) {
        return this.p.finally(onFinally, controller);
    }
    /**
     * Refreshes the timer to the original delay and updates the scheduled time.
     * If the timer has already ended this does nothing.
     */
    refresh() {
        if (this.timeoutRef == null)
            throw new errors_1.ErrorTimerEnded();
        this.timeoutRef.refresh();
        this._scheduled = new Date(perf_hooks_1.performance.timeOrigin + perf_hooks_1.performance.now() + this._delay);
    }
    /**
     * Resets the timer with a new delay and updates the scheduled time and delay.
     */
    reset(delay) {
        if (this.timeoutRef == null)
            throw new errors_1.ErrorTimerEnded();
        // This needs to re-create the timeout with the constructor logic.
        clearTimeout(this.timeoutRef);
        // If the delay is Infinity, this promise will never resolve
        // it may still reject however
        this._delay = delay;
        if (isFinite(delay)) {
            this.timeoutRef = setTimeout(() => void this.fulfill(), delay);
            this._scheduled = new Date(perf_hooks_1.performance.timeOrigin + perf_hooks_1.performance.now() + delay);
        }
        else {
            // Infinite interval, make sure you are cancelling the `Timer`
            // otherwise you will keep the process alive
            this.timeoutRef = setInterval(() => { }, 2 ** 31 - 1);
            this._scheduled = undefined;
        }
    }
    async fulfill() {
        this._status = 'settling';
        clearTimeout(this.timeoutRef);
        delete this.timeoutRef;
        if (this.handler != null) {
            try {
                const result = await this.handler(this.abortController.signal);
                this.resolveP(result);
            }
            catch (e) {
                this.rejectP(e);
            }
        }
        else {
            this.resolveP();
        }
        delete this.handler;
        this._status = 'settled';
    }
    async reject(reason) {
        if ((this.lazy && this._status === 'settling') ||
            this._status === 'settled') {
            return;
        }
        this._status = 'settling';
        clearTimeout(this.timeoutRef);
        delete this.timeoutRef;
        this.rejectP(reason);
        delete this.handler;
        this._status = 'settled';
    }
}
exports.default = Timer;
//# sourceMappingURL=Timer.js.map