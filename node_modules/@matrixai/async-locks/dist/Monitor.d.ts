import type { ResourceRelease } from '@matrixai/resources';
import type RWLockWriter from './RWLockWriter';
import type RWLockReader from './RWLockReader';
import type LockBox from './LockBox';
import type { ResourceAcquireCancellable, Lockable, RWLockRequest, ContextTimedInput } from './types';
import { PromiseCancellable } from '@matrixai/async-cancellable';
declare class Monitor<RWLock extends RWLockReader | RWLockWriter> implements Lockable {
    /**
     * Global lock box.
     * Must be shared between all monitors.
     */
    protected lockBox: LockBox<RWLock>;
    /**
     * Lock constructor to be used.
     */
    protected lockConstructor: new () => RWLock;
    /**
     * Global pending locks map.
     * Only used for deadlock detection.
     */
    protected locksPending?: Map<string, {
        count: number;
    }>;
    /**
     * Monitor specific lock map.
     */
    protected _locks: Map<string, {
        status: 'acquiring';
        type: 'read' | 'write';
    } | {
        status: 'acquired';
        type: 'read' | 'write';
        lock: RWLock;
        release: ResourceRelease;
    }>;
    constructor(lockBox: LockBox<RWLock>, lockConstructor: new () => RWLock, locksPending?: Map<string, {
        count: number;
    }>);
    get locks(): ReadonlyMap<string, {
        status: 'acquiring';
        type: 'read' | 'write';
    } | {
        status: 'acquired';
        type: 'read' | 'write';
        lock: RWLock;
        release: ResourceRelease;
    }>;
    /**
     * The monitor count is isolated to this monitor.
     * Use the shared lock box if you want to know the global count.
     */
    get count(): number;
    /**
     * This checks if this monitor has locked the lock.
     * Use the shared lock box if you want to know if it is globally locked.
     */
    isLocked(key?: string, type?: 'read' | 'write'): boolean;
    /**
     * Lock a sequence of lock requests.
     * This defaults to using `write` locks the type is not specified.
     * Keys are locked in string sorted order.
     * Locking the same key is idempotent therefore lock re-entrancy is enabled.
     * Keys are automatically unlocked in reverse sorted order in case of rejection.
     * There is no support for lock upgrading or downgrading.
     * Re-entrancy should work concurrently.
     */
    lock(...params: [
        ...requests: Array<RWLockRequest | string>,
        ctx: Partial<ContextTimedInput>
    ] | [...requests: Array<RWLockRequest | string>] | [ctx?: Partial<ContextTimedInput>]): ResourceAcquireCancellable<Monitor<RWLock>>;
    /**
     * Unlock a sequence of lock keys.
     * Unlocking will be done in the order of the keys.
     * Unlocking can only be done for the keys locked by this monitor.
     * Unlocking the same keys is idempotent.
     */
    unlock(...keys: Array<string>): Promise<void>;
    unlockAll(): Promise<void>;
    /**
     * This waits for a lock in this specific monitor.
     * Use the shared lock box if you want globally wait for unlock.
     */
    waitForUnlock(...params: [key?: string, ctx?: Partial<ContextTimedInput>] | [key?: string] | [ctx?: Partial<ContextTimedInput>] | []): PromiseCancellable<void>;
    withF<T>(...params: [
        ...([
            ...requests: Array<RWLockRequest | string>,
            ctx: Partial<ContextTimedInput>
        ] | [...requests: Array<RWLockRequest | string>] | [ctx?: Partial<ContextTimedInput>]),
        (monitor: Monitor<RWLock>) => Promise<T>
    ]): Promise<T>;
    withG<T, TReturn, TNext>(...params: [
        ...([
            ...requests: Array<RWLockRequest | string>,
            ctx: Partial<ContextTimedInput>
        ] | [...requests: Array<RWLockRequest | string>] | [ctx?: Partial<ContextTimedInput>]),
        (monitor: Monitor<RWLock>) => AsyncGenerator<T, TReturn, TNext>
    ]): AsyncGenerator<T, TReturn, TNext>;
    protected setPendingLock(key: string, lockType: 'read' | 'write'): [string, {
        count: number;
    }];
    protected unsetPendingLock(lockPendingKey: string, lockPending: {
        count: number;
    }): void;
    protected checkForDeadlock(key: string, lockType: 'read' | 'write'): boolean;
}
export default Monitor;
