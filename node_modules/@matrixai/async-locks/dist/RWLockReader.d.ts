import type { ResourceRelease } from '@matrixai/resources';
import type { ResourceAcquireCancellable, Lockable, ContextTimedInput } from './types';
import { PromiseCancellable } from '@matrixai/async-cancellable';
import Lock from './Lock';
/**
 * Read-preferring read write lock
 */
declare class RWLockReader implements Lockable {
    protected readersLock: Lock;
    protected writersLock: Lock;
    protected writersRelease: ResourceRelease;
    protected readerCountBlocked: number;
    protected _readerCount: number;
    protected _writerCount: number;
    protected acquireWritersLockP: PromiseCancellable<readonly [ResourceRelease, Lock?]>;
    get count(): number;
    get readerCount(): number;
    get writerCount(): number;
    /**
     * Check if locked
     * If passed `type`, it will also check that the active lock is of that type
     */
    isLocked(type?: 'read' | 'write'): boolean;
    lock(...params: [type?: 'read' | 'write', ctx?: Partial<ContextTimedInput>] | [type?: 'read' | 'write'] | [ctx?: Partial<ContextTimedInput>] | []): ResourceAcquireCancellable<RWLockReader>;
    read(ctx?: Partial<ContextTimedInput>): ResourceAcquireCancellable<RWLockReader>;
    write(ctx?: Partial<ContextTimedInput>): ResourceAcquireCancellable<RWLockReader>;
    waitForUnlock(ctx?: Partial<ContextTimedInput>): PromiseCancellable<void>;
    withF<T>(...params: [
        ...([type?: 'read' | 'write', ctx?: Partial<ContextTimedInput>] | [type?: 'read' | 'write'] | [ctx?: Partial<ContextTimedInput>] | []),
        (lock: RWLockReader) => Promise<T>
    ]): Promise<T>;
    withReadF<T>(...params: [
        ...([ctx?: Partial<ContextTimedInput>] | []),
        (lock: RWLockReader) => Promise<T>
    ]): Promise<T>;
    withWriteF<T>(...params: [
        ...([ctx?: Partial<ContextTimedInput>] | []),
        (lock: RWLockReader) => Promise<T>
    ]): Promise<T>;
    withG<T, TReturn, TNext>(...params: [
        ...([type?: 'read' | 'write', ctx?: Partial<ContextTimedInput>] | [type?: 'read' | 'write'] | [ctx?: Partial<ContextTimedInput>] | []),
        (lock: RWLockReader) => AsyncGenerator<T, TReturn, TNext>
    ]): AsyncGenerator<T, TReturn, TNext>;
    withReadG<T, TReturn, TNext>(...params: [
        ...([ctx?: Partial<ContextTimedInput>] | []),
        (lock: RWLockReader) => AsyncGenerator<T, TReturn, TNext>
    ]): AsyncGenerator<T, TReturn, TNext>;
    withWriteG<T, TReturn, TNext>(...params: [
        ...([ctx?: Partial<ContextTimedInput>] | []),
        (lock: RWLockReader) => AsyncGenerator<T, TReturn, TNext>
    ]): AsyncGenerator<T, TReturn, TNext>;
}
export default RWLockReader;
