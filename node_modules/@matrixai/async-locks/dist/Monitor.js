"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_cancellable_1 = require("@matrixai/async-cancellable");
const resources_1 = require("@matrixai/resources");
const errors = __importStar(require("./errors"));
class Monitor {
    /**
     * Global lock box.
     * Must be shared between all monitors.
     */
    lockBox;
    /**
     * Lock constructor to be used.
     */
    lockConstructor;
    /**
     * Global pending locks map.
     * Only used for deadlock detection.
     */
    locksPending;
    /**
     * Monitor specific lock map.
     */
    _locks = new Map();
    constructor(lockBox, lockConstructor, locksPending) {
        this.lockBox = lockBox;
        this.lockConstructor = lockConstructor;
        this.locksPending = locksPending;
    }
    get locks() {
        return this._locks;
    }
    /**
     * The monitor count is isolated to this monitor.
     * Use the shared lock box if you want to know the global count.
     */
    get count() {
        return this._locks.size;
    }
    /**
     * This checks if this monitor has locked the lock.
     * Use the shared lock box if you want to know if it is globally locked.
     */
    isLocked(key, type) {
        if (key == null) {
            for (const [key, lock] of this._locks.entries()) {
                if (lock.status === 'acquiring') {
                    // If pending, get it from the lockbox
                    if (this.lockBox.locks.get(key).isLocked(type))
                        return true;
                }
                else {
                    if (lock.lock.isLocked(type))
                        return true;
                }
            }
            return false;
        }
        else {
            const lock = this._locks.get(key);
            if (lock === undefined) {
                return false;
            }
            else {
                if (lock.status === 'acquiring') {
                    // If pending, get it from the lockbox
                    return this.lockBox.locks.get(key).isLocked(type);
                }
                else {
                    return lock.lock.isLocked(type);
                }
            }
        }
    }
    /**
     * Lock a sequence of lock requests.
     * This defaults to using `write` locks the type is not specified.
     * Keys are locked in string sorted order.
     * Locking the same key is idempotent therefore lock re-entrancy is enabled.
     * Keys are automatically unlocked in reverse sorted order in case of rejection.
     * There is no support for lock upgrading or downgrading.
     * Re-entrancy should work concurrently.
     */
    lock(...params) {
        const ctx = (!Array.isArray(params[params.length - 1]) &&
            typeof params[params.length - 1] !== 'string'
            ? params.pop()
            : undefined);
        const requests = params;
        return () => {
            let currentP;
            const f = async () => {
                const requests_ = [];
                for (const request of requests) {
                    if (Array.isArray(request)) {
                        const key = request[0];
                        // Default the lock type to `write`
                        const lockType = typeof request[1] === 'string' ? request[1] : 'write';
                        // Each lock request can have its own ctx, if it is `undefined`,
                        // it defaults to the method `ctx`.
                        const ctx_ = (typeof request[1] === 'string' ? request[2] : request[1]) ?? ctx;
                        const lock = this._locks.get(key);
                        if (lock === undefined) {
                            requests_.push([
                                key,
                                this.lockConstructor,
                                lockType,
                                ctx_,
                            ]);
                        }
                        else if (lock.type !== lockType) {
                            throw new errors.ErrorAsyncLocksMonitorLockType(`Cannot change lock type from ${lock.type} to ${lockType}`);
                        }
                    }
                    else {
                        const key = request;
                        const lock = this._locks.get(key);
                        if (lock === undefined) {
                            // Default the lock type to `write` and use the method `ctx`
                            requests_.push([key, this.lockConstructor, 'write', ctx]);
                        }
                        else if (lock.type !== 'write') {
                            throw new errors.ErrorAsyncLocksMonitorLockType(`Cannot change lock type from ${lock.type} to write`);
                        }
                    }
                }
                // Duplicates are eliminated, and the returned acquisitions are sorted
                const lockAcquires = this.lockBox.lockMulti(...requests_);
                const lockedKeys = [];
                try {
                    for (const [key, lockAcquire, ...lockingParams] of lockAcquires) {
                        const lockType = lockingParams[0];
                        const lockAcquireP = lockAcquire();
                        currentP = lockAcquireP;
                        let lockPendingKey = null;
                        let lockPending = null;
                        if (this.locksPending != null) {
                            // If we cancelling due to deadlock, we will not set the key into
                            // the global pending lock map.
                            if (this.checkForDeadlock(key, lockType)) {
                                lockAcquireP.cancel(new errors.ErrorAsyncLocksMonitorDeadlock());
                            }
                            else {
                                [lockPendingKey, lockPending] = this.setPendingLock(key, lockType);
                            }
                        }
                        let lockRelease, lock;
                        this._locks.set(key, { status: 'acquiring', type: lockType });
                        try {
                            [lockRelease, lock] = await lockAcquireP;
                        }
                        catch (e) {
                            // Remove the local acquisition
                            this._locks.delete(key);
                            throw e;
                        }
                        finally {
                            if (lockPendingKey !== null && lockPending !== null) {
                                this.unsetPendingLock(lockPendingKey, lockPending);
                            }
                        }
                        // The `Map` will maintain insertion order
                        // these must be unlocked in reverse order
                        // when the transaction is destroyed
                        this._locks.set(key, {
                            status: 'acquired',
                            lock: lock,
                            type: lockingParams[0],
                            release: lockRelease,
                        });
                        lockedKeys.push(key);
                    }
                }
                catch (e) {
                    // Reverse and unlock
                    lockedKeys.reverse();
                    await this.unlock(...lockedKeys);
                    throw e;
                }
                let released = false;
                return [
                    async () => {
                        if (released)
                            return;
                        released = true;
                        // Release all locks in reverse order
                        lockedKeys.reverse();
                        await this.unlock(...lockedKeys);
                    },
                    this,
                ];
            };
            return async_cancellable_1.PromiseCancellable.from(f(), (signal) => {
                signal.addEventListener('abort', () => {
                    currentP?.cancel(signal.reason);
                }, { once: true });
            });
        };
    }
    /**
     * Unlock a sequence of lock keys.
     * Unlocking will be done in the order of the keys.
     * Unlocking can only be done for the keys locked by this monitor.
     * Unlocking the same keys is idempotent.
     */
    async unlock(...keys) {
        for (const key of keys) {
            const lock = this._locks.get(key);
            if (lock === undefined)
                continue;
            if (lock.status === 'acquired') {
                // Only unlock acquired keys
                this._locks.delete(key);
                await lock.release();
            }
        }
    }
    async unlockAll() {
        const lockedKeys = [...this._locks.keys()].reverse();
        await this.unlock(...lockedKeys);
    }
    /**
     * This waits for a lock in this specific monitor.
     * Use the shared lock box if you want globally wait for unlock.
     */
    waitForUnlock(...params) {
        const key = params.length === 2
            ? params[0]
            : typeof params[0] === 'string'
                ? params[0]
                : undefined;
        const ctx = params.length === 2
            ? params[1]
            : typeof params[0] !== 'string'
                ? params[0]
                : undefined;
        if (key == null) {
            const waitPs = [];
            for (const [key, lock] of this._locks.entries()) {
                if (lock.status === 'acquiring') {
                    // If pending, get it from the lockbox
                    waitPs.push(this.lockBox.locks.get(key).waitForUnlock(ctx));
                }
                else {
                    waitPs.push(lock.lock.waitForUnlock(ctx));
                }
            }
            const waitP = Promise.all(waitPs).then(() => { });
            return async_cancellable_1.PromiseCancellable.from(waitP, (signal) => {
                signal.addEventListener('abort', () => {
                    waitPs.reverse();
                    for (const waitP of waitPs) {
                        waitP.cancel(signal.reason);
                    }
                }, { once: true });
            });
        }
        else {
            const lock = this._locks.get(key);
            if (lock === undefined)
                return async_cancellable_1.PromiseCancellable.resolve();
            if (lock.status === 'acquiring') {
                return this.lockBox.locks.get(key).waitForUnlock(ctx);
            }
            else {
                return lock.lock.waitForUnlock(ctx);
            }
        }
    }
    withF(...params) {
        const f = params.pop();
        return (0, resources_1.withF)([this.lock(...params)], ([monitor]) => f(monitor));
    }
    withG(...params) {
        const g = params.pop();
        return (0, resources_1.withG)([this.lock(...params)], ([monitor]) => g(monitor));
    }
    setPendingLock(key, lockType) {
        if (this.locksPending == null) {
            throw ReferenceError('Cannot set pending lock without pending locks map');
        }
        const lockPendingKey = JSON.stringify([key, lockType]);
        let lockPending = this.locksPending.get(lockPendingKey);
        if (lockPending == null) {
            lockPending = { count: 1 };
            this.locksPending.set(lockPendingKey, lockPending);
        }
        else {
            lockPending.count += 1;
        }
        return [lockPendingKey, lockPending];
    }
    unsetPendingLock(lockPendingKey, lockPending) {
        if (this.locksPending == null) {
            throw ReferenceError('Cannot unset pending lock without pending locks map');
        }
        lockPending.count -= 1;
        if (lockPending.count === 0) {
            this.locksPending.delete(lockPendingKey);
        }
    }
    checkForDeadlock(key, lockType) {
        if (this.locksPending == null) {
            throw ReferenceError('Cannot check for deadlock without pending locks map');
        }
        const lockObj = this.lockBox.locks.get(key);
        if (lockObj != null) {
            if ((lockType === 'read' && lockObj.isLocked('write')) ||
                (lockType === 'write' && lockObj.isLocked())) {
                // Check if other monitor's pending lock keys conflict with
                // this monitor's existing held locks.
                for (const lockPendingKey of this.locksPending.keys()) {
                    const [lockKeyPending, lockTypePending] = JSON.parse(lockPendingKey);
                    const lock = this._locks.get(lockKeyPending);
                    if (lock != null &&
                        (lock.type === 'write' || lockTypePending === 'write')) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
}
exports.default = Monitor;
//# sourceMappingURL=Monitor.js.map