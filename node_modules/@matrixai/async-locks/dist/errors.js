"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorAsyncLocksMonitorDeadlock = exports.ErrorAsyncLocksMonitorLockType = exports.ErrorAsyncLocksLockBoxConflict = exports.ErrorAsyncLocksTimeout = exports.ErrorAsyncLocks = void 0;
const errors_1 = require("@matrixai/errors");
class ErrorAsyncLocks extends errors_1.AbstractError {
    static description = 'Async locks error';
}
exports.ErrorAsyncLocks = ErrorAsyncLocks;
class ErrorAsyncLocksTimeout extends ErrorAsyncLocks {
    static description = 'Async locks timeout';
}
exports.ErrorAsyncLocksTimeout = ErrorAsyncLocksTimeout;
class ErrorAsyncLocksLockBoxConflict extends ErrorAsyncLocks {
    static description = 'LockBox cannot lock same ID with different Lockable classes';
}
exports.ErrorAsyncLocksLockBoxConflict = ErrorAsyncLocksLockBoxConflict;
/**
 * If you get this exception, this means within the same `Monitor` instance,
 * you tried to lock a read on a key that is already locked for write, or
 * you tried to lock a write on a key that is already locked for read. This
 * is not supported because to do so would imply a lock upgrade from read to
 * write or from write to read.
 */
class ErrorAsyncLocksMonitorLockType extends ErrorAsyncLocks {
    static description = 'Monitor does not support upgrading or downgrading the lock type';
}
exports.ErrorAsyncLocksMonitorLockType = ErrorAsyncLocksMonitorLockType;
class ErrorAsyncLocksMonitorDeadlock extends ErrorAsyncLocks {
    static description = 'Monitor has met a potential deadlock';
}
exports.ErrorAsyncLocksMonitorDeadlock = ErrorAsyncLocksMonitorDeadlock;
//# sourceMappingURL=errors.js.map