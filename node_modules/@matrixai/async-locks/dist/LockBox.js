"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_cancellable_1 = require("@matrixai/async-cancellable");
const resources_1 = require("@matrixai/resources");
const utils = __importStar(require("./utils"));
const errors = __importStar(require("./errors"));
class LockBox {
    _locks = new Map();
    get locks() {
        return this._locks;
    }
    get count() {
        let count = 0;
        for (const lock of this._locks.values()) {
            count += lock.count;
        }
        return count;
    }
    isLocked(key, ...params) {
        if (key == null) {
            for (const lock of this._locks.values()) {
                if (lock.isLocked(...params))
                    return true;
            }
            return false;
        }
        else {
            const lock = this._locks.get(key);
            if (lock == null)
                return false;
            return lock.isLocked(...params);
        }
    }
    lock(...params) {
        let ctx = (!Array.isArray(params[params.length - 1]) ? params.pop() : undefined);
        ctx = ctx != null ? { ...ctx } : {};
        const requests = params;
        return () => {
            return utils.setupTimedCancellable(async (ctx) => {
                // This creates a copy of the requests
                let requests_ = [...requests];
                // Sort to ensure lock hierarchy
                requests_.sort(([key1], [key2]) => {
                    // Deterministic string comparison according to 16-bit code units
                    if (key1 < key2)
                        return -1;
                    if (key1 > key2)
                        return 1;
                    return 0;
                });
                // Avoid duplicate locking
                requests_ = requests_.filter(([key], i, arr) => i === 0 || key !== arr[i - 1][0]);
                const locks = [];
                try {
                    for (const [key, LockConstructor, ...lockingParams] of requests_) {
                        let lock = this._locks.get(key);
                        if (lock == null) {
                            lock = new LockConstructor();
                            this._locks.set(key, lock);
                        }
                        else {
                            // It is possible to swap the lock class, but only after the lock key is released
                            if (!(lock instanceof LockConstructor)) {
                                throw new errors.ErrorAsyncLocksLockBoxConflict(`Lock ${key} is already locked with class ${lock.constructor.name}, which conflicts with class ${LockConstructor.name}`);
                            }
                        }
                        const lockAcquire = lock.lock(...lockingParams, ctx);
                        const lockAcquireP = lockAcquire();
                        const [lockRelease] = await lockAcquireP;
                        locks.push([key, lockRelease, lock]);
                    }
                }
                catch (e) {
                    // Release all intermediate locks in reverse order
                    locks.reverse();
                    for (const [key, lockRelease, lock] of locks) {
                        await lockRelease();
                        // If it is still locked, then it is held by a different context
                        // only delete if no contexts are locking the lock
                        if (!lock.isLocked()) {
                            this._locks.delete(key);
                        }
                    }
                    throw e;
                }
                let released = false;
                return [
                    async () => {
                        if (released)
                            return;
                        released = true;
                        // Release all locks in reverse order
                        locks.reverse();
                        for (const [key, lockRelease, lock] of locks) {
                            await lockRelease();
                            // If it is still locked, then it is held by a different context
                            // only delete if no contexts are locking the lock
                            if (!lock.isLocked()) {
                                this._locks.delete(key);
                            }
                        }
                    },
                    this,
                ];
            }, true, Infinity, errors.ErrorAsyncLocksTimeout, ctx, []);
        };
    }
    lockMulti(...requests) {
        // This creates a copy of the requests
        let requests_ = [...requests];
        // Sort to ensure lock hierarchy
        requests_.sort(([key1], [key2]) => {
            // Deterministic string comparison according to 16-bit code units
            if (key1 < key2)
                return -1;
            if (key1 > key2)
                return 1;
            return 0;
        });
        // Avoid duplicate locking
        requests_ = requests_.filter(([key], i, arr) => i === 0 || key !== arr[i - 1][0]);
        const lockAcquires = [];
        for (const [key, LockConstructor, ...lockingParams] of requests_) {
            const lockAcquire = () => {
                let currentP;
                const f = async () => {
                    let lock = this._locks.get(key);
                    let lockRelease;
                    try {
                        if (lock == null) {
                            lock = new LockConstructor();
                            this._locks.set(key, lock);
                        }
                        else {
                            // It is possible to swap the lock class, but only after the lock key is released
                            if (!(lock instanceof LockConstructor)) {
                                throw new errors.ErrorAsyncLocksLockBoxConflict(`Lock ${key} is already locked with class ${lock.constructor.name}, which conflicts with class ${LockConstructor.name}`);
                            }
                        }
                        const lockAcquire = lock.lock(...lockingParams);
                        const lockAcquireP = lockAcquire();
                        currentP = lockAcquireP;
                        [lockRelease] = await lockAcquireP;
                    }
                    catch (e) {
                        // If it is still locked, then it is held by a different context
                        // only delete if no contexts are locking the lock
                        if (!lock.isLocked()) {
                            this._locks.delete(key);
                        }
                        throw e;
                    }
                    let released = false;
                    return [
                        async () => {
                            if (released)
                                return;
                            released = true;
                            await lockRelease();
                            // If it is still locked, then it is held by a different context
                            // only delete if no contexts are locking the lock
                            if (!lock.isLocked()) {
                                this._locks.delete(key);
                            }
                        },
                        lock,
                    ];
                };
                return async_cancellable_1.PromiseCancellable.from(f(), (signal) => {
                    signal.addEventListener('abort', () => {
                        currentP.cancel(signal.reason);
                    }, { once: true });
                });
            };
            lockAcquires.push([key, lockAcquire, ...lockingParams]);
        }
        return lockAcquires;
    }
    waitForUnlock(...params) {
        const key = params.length === 2
            ? params[0]
            : typeof params[0] === 'string'
                ? params[0]
                : undefined;
        const ctx = params.length === 2
            ? params[1]
            : typeof params[0] !== 'string'
                ? params[0]
                : undefined;
        if (key == null) {
            const waitPs = [];
            for (const lock of this._locks.values()) {
                waitPs.push(lock.waitForUnlock(ctx));
            }
            const waitP = Promise.all(waitPs).then(() => { });
            return async_cancellable_1.PromiseCancellable.from(waitP, (signal) => {
                signal.addEventListener('abort', () => {
                    waitPs.reverse();
                    for (const waitP of waitPs) {
                        waitP.cancel(signal.reason);
                    }
                }, { once: true });
            });
        }
        else {
            const lock = this._locks.get(key);
            if (lock == null)
                return async_cancellable_1.PromiseCancellable.resolve();
            return lock.waitForUnlock(ctx);
        }
    }
    withF(...params) {
        const f = params.pop();
        return (0, resources_1.withF)([this.lock(...params)], ([lockBox]) => f(lockBox));
    }
    withMultiF(...params) {
        const f = params.pop();
        const lockAcquires = this.lockMulti(...params);
        const lockAcquires_ = lockAcquires.map(([key, lockAcquire, ...lockingParams]) => (...r) => lockAcquire(...r).then(([lockRelease, lock]) => [lockRelease, [key, lock, ...lockingParams]]));
        return (0, resources_1.withF)(lockAcquires_, f);
    }
    withG(...params) {
        const g = params.pop();
        return (0, resources_1.withG)([this.lock(...params)], ([lockBox]) => g(lockBox));
    }
    withMultiG(...params) {
        const g = params.pop();
        const lockAcquires = this.lockMulti(...params);
        const lockAcquires_ = lockAcquires.map(([key, lockAcquire, ...lockingParams]) => (...r) => lockAcquire(...r).then(([lockRelease, lock]) => [lockRelease, [key, lock, ...lockingParams]]));
        return (0, resources_1.withG)(lockAcquires_, g);
    }
}
exports.default = LockBox;
//# sourceMappingURL=LockBox.js.map