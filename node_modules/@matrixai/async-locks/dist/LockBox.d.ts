import type { ResourceAcquireCancellable, Lockable, LockRequest, LockAcquireCancellable, LockAcquired, ContextTimedInput } from './types';
import { PromiseCancellable } from '@matrixai/async-cancellable';
declare class LockBox<L extends Lockable = Lockable> implements Lockable {
    protected _locks: Map<string, L>;
    get locks(): ReadonlyMap<string, L>;
    get count(): number;
    isLocked(key?: string, ...params: Parameters<L['isLocked']>): boolean;
    lock(...params: [...requests: Array<LockRequest<L>>, ctx: Partial<ContextTimedInput>] | [...requests: Array<LockRequest<L>>] | [ctx?: Partial<ContextTimedInput>]): ResourceAcquireCancellable<LockBox<L>>;
    lockMulti(...requests: Array<LockRequest<L>>): Array<LockAcquireCancellable<L>>;
    waitForUnlock(...params: [key?: string, ctx?: Partial<ContextTimedInput>] | [key?: string] | [ctx?: Partial<ContextTimedInput>] | []): PromiseCancellable<void>;
    withF<T>(...params: [
        ...([...requests: Array<LockRequest<L>>, ctx: Partial<ContextTimedInput>] | [...requests: Array<LockRequest<L>>] | [ctx?: Partial<ContextTimedInput>]),
        (lockBox: LockBox<L>) => Promise<T>
    ]): Promise<T>;
    withMultiF<T>(...params: [
        ...requests: Array<LockRequest<L>>,
        f: (multiLocks: Array<LockAcquired<L>>) => Promise<T>
    ]): Promise<T>;
    withG<T, TReturn, TNext>(...params: [
        ...([...requests: Array<LockRequest<L>>, ctx: Partial<ContextTimedInput>] | [...requests: Array<LockRequest<L>>] | [ctx?: Partial<ContextTimedInput>]),
        (lockBox: LockBox<L>) => AsyncGenerator<T, TReturn, TNext>
    ]): AsyncGenerator<T, TReturn, TNext>;
    withMultiG<T, TReturn, TNext>(...params: [
        ...requests: Array<LockRequest<L>>,
        g: (multiLocks: Array<LockAcquired<L>>) => AsyncGenerator<T, TReturn, TNext>
    ]): AsyncGenerator<T, TReturn, TNext>;
}
export default LockBox;
