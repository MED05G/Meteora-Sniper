import type { PromiseCancellable } from '@matrixai/async-cancellable';
import type { ResourceAcquireCancellable, Lockable, ContextTimedInput } from './types';
type Task = {
    task: () => void;
    weight: number;
    abortHandler: () => void;
    aborted?: boolean;
};
declare class Semaphore implements Lockable {
    readonly limit: number;
    readonly priority: boolean;
    protected _count: number;
    protected currentWeight: number;
    protected queue: Array<Task>;
    protected abortQueueMap: WeakMap<() => void, Task>;
    constructor(limit: number, priority?: boolean);
    get count(): number;
    /**
     * This will be true synchronously upon calling `this.lock()()`.
     */
    isLocked(): boolean;
    lock(...params: [weight?: number, ctx?: Partial<ContextTimedInput>] | [weight?: number] | [ctx?: Partial<ContextTimedInput>] | []): ResourceAcquireCancellable<Semaphore>;
    waitForUnlock(...params: [weight?: number, ctx?: Partial<ContextTimedInput>] | [weight?: number] | [ctx?: Partial<ContextTimedInput>] | []): PromiseCancellable<void>;
    withF<T>(...params: [
        ...([weight?: number, ctx?: Partial<ContextTimedInput>] | [weight?: number] | [ctx?: Partial<ContextTimedInput>] | []),
        (semaphore: Semaphore) => Promise<T>
    ]): Promise<T>;
    withG<T, TReturn, TNext>(...params: [
        ...([weight?: number, ctx?: Partial<ContextTimedInput>] | [weight?: number] | [ctx?: Partial<ContextTimedInput>] | []),
        (semaphore: Semaphore) => AsyncGenerator<T, TReturn, TNext>
    ]): AsyncGenerator<T, TReturn, TNext>;
    protected insertQueue(task: Task): void;
    protected processQueue(): void;
}
export default Semaphore;
