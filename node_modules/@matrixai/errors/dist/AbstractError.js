"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const perf_hooks_1 = require("perf_hooks");
const ts_custom_error_1 = require("ts-custom-error");
/**
 * Abstract error
 * Intended for further extension
 */
class AbstractError extends ts_custom_error_1.CustomError {
    /**
     * Static description of exception
     */
    static description = '';
    /**
     * Runtime decoding of JSON POJO to exception instance
     * When overriding this, you cannot use `super.fromJSON`
     * You must write it fully, and use the same type-hacks
     * to support polymorphic `this` in static methods
     * https://github.com/microsoft/TypeScript/issues/5863
     */
    static fromJSON(json) {
        if (typeof json !== 'object' ||
            json.type !== this.name ||
            typeof json.data !== 'object' ||
            typeof json.data.message !== 'string' ||
            isNaN(Date.parse(json.data.timestamp)) ||
            typeof json.data.data !== 'object' ||
            ('stack' in json.data && typeof json.data.stack !== 'string')) {
            throw new TypeError(`Cannot decode JSON to ${this.name}`);
        }
        const e = new this(json.data.message, {
            timestamp: new Date(json.data.timestamp),
            data: json.data.data,
            cause: json.data.cause,
        });
        e.stack = json.data.stack;
        return e;
    }
    /**
     * Arbitrary data
     */
    data;
    /**
     * Causation of the exception
     * Can be used to know what caused this exception
     */
    cause;
    /**
     * Timestamp when exception was constructed in milliseconds
     * Guaranteed to be weakly monotonic
     */
    timestamp;
    constructor(message = '', options = {}) {
        super(message);
        this.timestamp =
            options.timestamp ?? new Date(perf_hooks_1.performance.timeOrigin + perf_hooks_1.performance.now());
        this.data = options.data ?? {};
        this.cause = options.cause;
    }
    get description() {
        return this.constructor['description'];
    }
    /**
     * Encoding to JSON pojo
     * When overriding this, you can use `super.toJSON`
     * The `replacer` will:
     *  - delete undefined values in objects
     *  - replace undefined values for null in arrays
     */
    toJSON() {
        return {
            type: this.constructor.name,
            data: {
                message: this.message,
                timestamp: this.timestamp,
                data: this.data,
                cause: this.cause,
                stack: this.stack,
            },
        };
    }
}
exports.default = AbstractError;
//# sourceMappingURL=AbstractError.js.map