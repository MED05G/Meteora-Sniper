"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAsyncGenerator = exports.isGenerator = exports.isPromiseLike = exports.monitor = exports.timer = exports.checkContextTimed = exports.checkContextCancellable = exports.getContextIndex = exports.contexts = exports.AsyncGeneratorFunction = exports.GeneratorFunction = exports.AsyncFunction = void 0;
const timer_1 = require("@matrixai/timer");
const async_locks_1 = require("@matrixai/async-locks");
const AsyncFunction = (async () => { }).constructor;
exports.AsyncFunction = AsyncFunction;
const GeneratorFunction = function* () { }.constructor;
exports.GeneratorFunction = GeneratorFunction;
const AsyncGeneratorFunction = async function* () { }.constructor;
exports.AsyncGeneratorFunction = AsyncGeneratorFunction;
const contexts = new WeakMap();
exports.contexts = contexts;
function getContextIndex(target, key, targetName) {
    const contextIndex = contexts.get(target[key]);
    if (contextIndex == null) {
        throw new TypeError(`\`${targetName}.${key.toString()}\` does not have a \`@context\` parameter decorator`);
    }
    return contextIndex;
}
exports.getContextIndex = getContextIndex;
function checkContextCancellable(ctx, key, targetName) {
    if (typeof ctx !== 'object' || ctx === null) {
        throw new TypeError(`\`${targetName}.${key.toString()}\` decorated \`@context\` parameter is not a context object`);
    }
    if (ctx.signal !== undefined && !(ctx.signal instanceof AbortSignal)) {
        throw new TypeError(`\`${targetName}.${key.toString()}\` decorated \`@context\` parameter's \`signal\` property is not an instance of \`AbortSignal\``);
    }
}
exports.checkContextCancellable = checkContextCancellable;
function checkContextTimed(ctx, key, targetName) {
    if (typeof ctx !== 'object' || ctx === null) {
        throw new TypeError(`\`${targetName}.${key.toString()}\` decorated \`@context\` parameter is not a context object`);
    }
    if (ctx.signal !== undefined && !(ctx.signal instanceof AbortSignal)) {
        throw new TypeError(`\`${targetName}.${key.toString()}\` decorated \`@context\` parameter's \`signal\` property is not an instance of \`AbortSignal\``);
    }
    if (ctx.timer !== undefined &&
        !(typeof ctx.timer === 'number' || ctx.timer instanceof timer_1.Timer)) {
        throw new TypeError(`\`${targetName}.${key.toString()}\` decorated \`@context\` parameter's \`timer\` property is not a number nor an instance of \`Timer\``);
    }
}
exports.checkContextTimed = checkContextTimed;
/**
 * Timer resource
 * Use it with `withF` or `withG`.
 */
function timer(handlerOrOpts, delay = 0, lazy = false, controller) {
    return async () => {
        let timer;
        if (typeof handlerOrOpts === 'function') {
            timer = new timer_1.Timer(handlerOrOpts, delay, lazy, controller);
        }
        else {
            timer = new timer_1.Timer(handlerOrOpts);
        }
        return [
            async () => {
                timer.cancel();
            },
            timer,
        ];
    };
}
exports.timer = timer;
function monitor(lockBox, lockConstructor, locksPending) {
    return async () => {
        const monitor = new async_locks_1.Monitor(lockBox, lockConstructor, locksPending);
        return [
            async () => {
                await monitor.unlockAll();
            },
            monitor,
        ];
    };
}
exports.monitor = monitor;
function isPromiseLike(v) {
    return v != null && typeof v.then === 'function';
}
exports.isPromiseLike = isPromiseLike;
/**
 * Is generator object
 * Use this to check for generators
 */
function isGenerator(v) {
    return (v != null &&
        typeof v[Symbol.iterator] === 'function' &&
        typeof v.next === 'function' &&
        typeof v.return === 'function' &&
        typeof v.throw === 'function');
}
exports.isGenerator = isGenerator;
/**
 * Is async generator object
 * Use this to check for async generators
 */
function isAsyncGenerator(v) {
    return (v != null &&
        typeof v === 'object' &&
        typeof v[Symbol.asyncIterator] === 'function' &&
        typeof v.next === 'function' &&
        typeof v.return === 'function' &&
        typeof v.throw === 'function');
}
exports.isAsyncGenerator = isAsyncGenerator;
//# sourceMappingURL=utils.js.map