import type { ResourceAcquire } from '@matrixai/resources';
import type { PromiseCancellableController } from '@matrixai/async-cancellable';
import type { RWLockReader, RWLockWriter, LockBox } from '@matrixai/async-locks';
import { Timer } from '@matrixai/timer';
import { Monitor } from '@matrixai/async-locks';
declare const AsyncFunction: Function;
declare const GeneratorFunction: Function;
declare const AsyncGeneratorFunction: Function;
declare const contexts: WeakMap<object, number>;
declare function getContextIndex(target: any, key: string | symbol, targetName: string): number;
declare function checkContextCancellable(ctx: any, key: string | symbol, targetName: string): void;
declare function checkContextTimed(ctx: any, key: string | symbol, targetName: string): void;
/**
 * Timer resource
 * Use it with `withF` or `withG`.
 */
declare function timer<T = void>(handlerOrOpts?: ((signal: AbortSignal) => T | PromiseLike<T>) | {
    handler?: (signal: AbortSignal) => T | PromiseLike<T>;
    delay?: number;
    lazy?: boolean;
    controller?: PromiseCancellableController;
}, delay?: number, lazy?: boolean, controller?: PromiseCancellableController): ResourceAcquire<Timer<T>>;
declare function monitor<RWLock extends RWLockReader | RWLockWriter>(lockBox: LockBox<RWLock>, lockConstructor: new () => RWLock, locksPending?: Map<string, {
    count: number;
}>): ResourceAcquire<Monitor<RWLock>>;
declare function isPromiseLike(v: any): v is PromiseLike<unknown>;
/**
 * Is generator object
 * Use this to check for generators
 */
declare function isGenerator(v: any): v is Generator<unknown>;
/**
 * Is async generator object
 * Use this to check for async generators
 */
declare function isAsyncGenerator(v: any): v is AsyncGenerator<unknown>;
export { AsyncFunction, GeneratorFunction, AsyncGeneratorFunction, contexts, getContextIndex, checkContextCancellable, checkContextTimed, timer, monitor, isPromiseLike, isGenerator, isAsyncGenerator, };
