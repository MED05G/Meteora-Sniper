"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupCancellable = void 0;
const async_cancellable_1 = require("@matrixai/async-cancellable");
function setupCancellable(f, lazy, ctx, args) {
    if (ctx.signal === undefined) {
        const abortController = new AbortController();
        ctx.signal = abortController.signal;
        const result = f(ctx, ...args);
        return new async_cancellable_1.PromiseCancellable((resolve, reject, signal) => {
            if (!lazy) {
                signal.addEventListener('abort', () => {
                    reject(signal.reason);
                });
            }
            void result.then(resolve, reject);
        }, abortController);
    }
    else {
        // In this case, `context.signal` is set
        // and we chain the upsteam signal to the downstream signal
        const abortController = new AbortController();
        const signalUpstream = ctx.signal;
        const signalHandler = () => {
            abortController.abort(signalUpstream.reason);
        };
        if (signalUpstream.aborted) {
            abortController.abort(signalUpstream.reason);
        }
        else {
            signalUpstream.addEventListener('abort', signalHandler);
        }
        // Overwrite the signal property with this context's `AbortController.signal`
        ctx.signal = abortController.signal;
        const result = f(ctx, ...args);
        // The `abortController` must be shared in the `finally` clause
        // to link up final promise's cancellation with the target
        // function's signal
        return new async_cancellable_1.PromiseCancellable((resolve, reject, signal) => {
            if (!lazy) {
                if (signal.aborted) {
                    reject(signal.reason);
                }
                else {
                    signal.addEventListener('abort', () => {
                        reject(signal.reason);
                    });
                }
            }
            void result.then(resolve, reject);
        }, abortController).finally(() => {
            signalUpstream.removeEventListener('abort', signalHandler);
        }, abortController);
    }
}
exports.setupCancellable = setupCancellable;
function cancellable(f, lazy = false) {
    return (...params) => {
        const ctx = params[0] != null ? { ...params[0] } : {};
        const args = params.slice(1);
        return setupCancellable(f, lazy, ctx, args);
    };
}
exports.default = cancellable;
//# sourceMappingURL=cancellable.js.map