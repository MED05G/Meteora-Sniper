"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleEventError = exports.eventHandled = exports.eventHandlers = exports.eventTarget = exports.Evented = void 0;
const EventAll_1 = __importDefault(require("./EventAll"));
const EventDefault_1 = __importDefault(require("./EventDefault"));
const EventError_1 = __importDefault(require("./EventError"));
const utils_1 = require("./utils");
Object.defineProperty(exports, "eventTarget", { enumerable: true, get: function () { return utils_1.eventTarget; } });
Object.defineProperty(exports, "eventHandlers", { enumerable: true, get: function () { return utils_1.eventHandlers; } });
Object.defineProperty(exports, "eventHandled", { enumerable: true, get: function () { return utils_1.eventHandled; } });
Object.defineProperty(exports, "handleEventError", { enumerable: true, get: function () { return utils_1.handleEventError; } });
function Evented() {
    return (constructor) => {
        const constructor_ = class extends constructor {
            [utils_1._eventTarget] = new EventTarget();
            [utils_1._eventHandlers] = new Map();
            [utils_1._eventHandled] = new WeakSet();
            [utils_1._handleEventError] = (evt) => {
                throw evt.detail;
            };
            constructor(...args) {
                super(...args);
                // Default `EventError` handler
                this[utils_1._eventTarget].addEventListener(EventError_1.default.name, this[utils_1._handleEventError]);
            }
            get [utils_1.eventTarget]() {
                return this[utils_1._eventTarget];
            }
            get [utils_1.eventHandlers]() {
                return this[utils_1._eventHandlers];
            }
            get [utils_1.eventHandled]() {
                return this[utils_1._eventHandled];
            }
            get [utils_1.handleEventError]() {
                return this[utils_1._handleEventError];
            }
            /**
             * This can be O(n) per type due to searching for both handler and options.
             */
            addEventListener(type, callback, options) {
                options = (0, utils_1.canonicalizeOptions)(options);
                const that = this;
                // Get the previously wrapped handler if it exists
                let handler;
                let handlerSet;
                let optionsEqual = false;
                if (typeof callback === 'function' ||
                    typeof callback?.handleEvent === 'function') {
                    handlerSet = this[utils_1._eventHandlers].get(type);
                    if (handlerSet === undefined) {
                        handlerSet = new Set();
                        this[utils_1._eventHandlers].set(type, handlerSet);
                    }
                    for (const handlerInfo of handlerSet) {
                        if (handlerInfo.callback === callback) {
                            handler = handlerInfo.handler;
                            if ((0, utils_1.isEqualOptions)(handlerInfo.options, options)) {
                                optionsEqual = true;
                                break;
                            }
                        }
                    }
                }
                if (typeof callback === 'function') {
                    if (handler == null) {
                        handler = async function (e) {
                            // Indicate that the event is now handled
                            // It must done earlier in case the callback is asynchronous
                            that[utils_1._eventHandled].add(e);
                            let result;
                            try {
                                // Propagate the `that`
                                result = callback.call(that, e);
                            }
                            catch (e) {
                                // Deal with the uncaught exception
                                this.dispatchEvent(new EventError_1.default({
                                    detail: e,
                                }));
                            }
                            // If the result is `PromiseLike` await the result
                            // This does use `await` on the callback in case it is synchronous
                            // in order to preserve operational microtask scheduling behaviour
                            // Deal with the unhandled rejection
                            if (typeof result?.then === 'function') {
                                try {
                                    await result;
                                }
                                catch (e) {
                                    this.dispatchEvent(new EventError_1.default({
                                        detail: e,
                                    }));
                                }
                            }
                        };
                        // Add new handler info because handler is new
                        handlerSet.add({
                            callback,
                            options,
                            handler,
                        });
                    }
                    else if (!optionsEqual) {
                        // Add new handler info with the same handler because options is different
                        handlerSet.add({
                            callback,
                            options,
                            handler: handler,
                        });
                    }
                }
                else if (typeof callback?.handleEvent === 'function') {
                    if (handler == null) {
                        handler = async function (e) {
                            // Indicate that the event is now handled
                            // It must done earlier in case the callback is asynchronous
                            that[utils_1._eventHandled].add(e);
                            let result;
                            try {
                                // Don't propagate the `that`
                                result = callback.handleEvent(e);
                            }
                            catch (e) {
                                // Deal with the uncaught exception
                                this.dispatchEvent(new EventError_1.default({
                                    detail: e,
                                }));
                            }
                            // If the result is `PromiseLike` await the result
                            // This does use `await` on the callback in case it is synchronous
                            // in order to preserve operational microtask scheduling behaviour
                            // Deal with the unhandled rejection
                            if (typeof result?.then === 'function') {
                                try {
                                    await result;
                                }
                                catch (e) {
                                    this.dispatchEvent(new EventError_1.default({
                                        detail: e,
                                    }));
                                }
                            }
                            return result;
                        };
                        // Add new handler info because handler is new
                        handlerSet.add({
                            callback,
                            options,
                            handler,
                        });
                    }
                    else if (!optionsEqual) {
                        // Add new handler info with the same handler because options is different
                        handlerSet.add({
                            callback,
                            options,
                            handler: handler,
                        });
                    }
                }
                else {
                    handler = callback;
                }
                this[utils_1._eventTarget].addEventListener(type, handler, options);
                // Disable the base error handler if there is at least one listener for errors
                if (type === EventError_1.default.name && handlerSet?.size === 1) {
                    this[utils_1._eventTarget].removeEventListener(EventError_1.default.name, this[utils_1._handleEventError]);
                }
            }
            /**
             * This can be O(n) per type due to searching for both handler and options.
             */
            removeEventListener(type, callback, options) {
                options = (0, utils_1.canonicalizeOptions)(options);
                let handler;
                let handlerSet;
                let handlerInfoToBeRemoved;
                if (callback != null) {
                    handlerSet = this[utils_1._eventHandlers].get(type);
                    if (handlerSet === undefined) {
                        return;
                    }
                    for (const handlerInfo of handlerSet) {
                        if (handlerInfo.callback === callback &&
                            (0, utils_1.isEqualOptions)(handlerInfo.options, options)) {
                            // The handler will be the same instance
                            handler = handlerInfo.handler;
                            handlerInfoToBeRemoved = handlerInfo;
                            break;
                        }
                    }
                    if (handler == null) {
                        return;
                    }
                }
                else {
                    handler = callback;
                }
                this[utils_1._eventTarget].removeEventListener(type, handler, options);
                if (handlerSet != null && handlerInfoToBeRemoved != null) {
                    handlerSet.delete(handlerInfoToBeRemoved);
                    // Enable the base error handler if there is no listener for errors
                    if (type === EventError_1.default.name && handlerSet.size === 0) {
                        this[utils_1._eventTarget].addEventListener(EventError_1.default.name, this[utils_1._handleEventError]);
                    }
                }
            }
            dispatchEvent(event) {
                // Override the `target` and `currentTarget` to point to the current object
                Object.defineProperties(event, {
                    target: {
                        value: this,
                        writable: false,
                    },
                    currentTarget: {
                        value: this,
                        writable: false,
                    },
                });
                if (event instanceof EventError_1.default) {
                    // If the event is `EventError`, we don't bother with `EventDefault` and `EventAll`
                    return this[utils_1._eventTarget].dispatchEvent(event);
                }
                else {
                    let status = this[utils_1._eventTarget].dispatchEvent(event);
                    if (status && !this[utils_1._eventHandled].has(event)) {
                        const eventDefault = new EventDefault_1.default({
                            bubbles: event.bubbles,
                            cancelable: event.cancelable,
                            composed: event.composed,
                            detail: event,
                        });
                        Object.defineProperties(eventDefault, {
                            target: {
                                value: this,
                                writable: false,
                            },
                            currentTarget: {
                                value: this,
                                writable: false,
                            },
                        });
                        status = this[utils_1._eventTarget].dispatchEvent(eventDefault);
                    }
                    if (status) {
                        const eventAll = new EventAll_1.default({
                            bubbles: event.bubbles,
                            cancelable: event.cancelable,
                            composed: event.composed,
                            detail: event,
                        });
                        Object.defineProperties(eventAll, {
                            target: {
                                value: this,
                                writable: false,
                            },
                            currentTarget: {
                                value: this,
                                writable: false,
                            },
                        });
                        status = this[utils_1._eventTarget].dispatchEvent(eventAll);
                    }
                    return status;
                }
            }
        };
        // Preserve the name
        Object.defineProperty(constructor_, 'name', Object.getOwnPropertyDescriptor(constructor, 'name'));
        return constructor_;
    };
}
exports.Evented = Evented;
//# sourceMappingURL=Evented.js.map