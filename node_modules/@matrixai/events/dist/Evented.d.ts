import type { ReadonlyWeakSet, EventHandlerInfo } from './types';
import EventError from './EventError';
import { _eventTarget, eventTarget, _eventHandlers, eventHandlers, _eventHandled, eventHandled, _handleEventError, handleEventError } from './utils';
interface Evented {
    get [eventTarget](): EventTarget;
    get [eventHandlers](): ReadonlyMap<string, Set<EventHandlerInfo>>;
    get [eventHandled](): ReadonlyWeakSet<Event>;
    get [handleEventError](): (evt: EventError) => void;
    addEventListener(type: string, callback: EventListenerOrEventListenerObject | null, options?: AddEventListenerOptions | boolean): void;
    removeEventListener(type: string, callback: EventListenerOrEventListenerObject | null, options?: EventListenerOptions | boolean): void;
    dispatchEvent(event: Event): boolean;
}
declare function Evented(): <T extends new (...args: any[]) => object>(constructor: T) => {
    new (...args: Array<any>): {
        /**
         * This can be O(n) per type due to searching for both handler and options.
         */
        addEventListener(type: string, callback: EventListenerOrEventListenerObject | null, options?: AddEventListenerOptions | boolean): void;
        /**
         * This can be O(n) per type due to searching for both handler and options.
         */
        removeEventListener(type: string, callback: EventListenerOrEventListenerObject | null, options?: EventListenerOptions | boolean): void;
        dispatchEvent(event: Event): boolean;
        [_eventTarget]: EventTarget;
        [_eventHandlers]: Map<string, Set<EventHandlerInfo>>;
        [_eventHandled]: WeakSet<Event>;
        [_handleEventError]: (evt: EventError) => void;
        readonly [eventTarget]: EventTarget;
        readonly [eventHandlers]: ReadonlyMap<string, Set<EventHandlerInfo>>;
        readonly [eventHandled]: ReadonlyWeakSet<Event>;
        readonly [handleEventError]: (evt: EventError) => void;
    };
} & T;
export { Evented, eventTarget, eventHandlers, eventHandled, handleEventError };
