"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class PromiseCancellable extends Promise {
    static get [Symbol.species]() {
        return Promise;
    }
    static resolve(value) {
        if (value instanceof PromiseCancellable)
            return value;
        return super.resolve(value);
    }
    static reject(reason) {
        return super.reject(reason);
    }
    static all(values, controller) {
        // The `super.all` calls `new PromiseCancellable`
        const pC = super.all(values);
        if (typeof controller === 'function') {
            pC.abortController = new AbortController();
            controller(pC.abortController.signal);
        }
        else if (controller != null) {
            pC.abortController = controller;
        }
        return pC;
    }
    static allSettled(values, controller) {
        // The `super.allSettled` calls `new PromiseCancellable`
        const pC = super.allSettled(values);
        if (typeof controller === 'function') {
            pC.abortController = new AbortController();
            controller(pC.abortController.signal);
        }
        else if (controller != null) {
            pC.abortController = controller;
        }
        return pC;
    }
    static race(values, controller) {
        // The `super.race` calls `new PromiseCancellable`
        const pC = super.race(values);
        if (typeof controller === 'function') {
            pC.abortController = new AbortController();
            controller(pC.abortController.signal);
        }
        else if (controller != null) {
            pC.abortController = controller;
        }
        return pC;
    }
    static any(values, controller) {
        // The `super.any` calls `new PromiseCancellable`
        const pC = super.any(values);
        if (typeof controller === 'function') {
            pC.abortController = new AbortController();
            controller(pC.abortController.signal);
        }
        else if (controller != null) {
            pC.abortController = controller;
        }
        return pC;
    }
    static from(p, controller) {
        return new this((resolve, reject) => {
            void p.then(resolve, reject);
        }, controller);
    }
    constructor(executor, controller) {
        let abortController;
        let signal;
        let signalHandled;
        if (typeof controller === 'function') {
            abortController = new AbortController();
            controller(abortController.signal);
            signal = abortController.signal;
            signalHandled = true;
        }
        else if (controller != null) {
            abortController = controller;
            signal = controller.signal;
            signalHandled = true;
        }
        else {
            abortController = new AbortController();
            signal = new Proxy(abortController.signal, {
                get(target, prop, receiver) {
                    if (prop === 'addEventListener') {
                        return function addEventListener(...args) {
                            signalHandled = true;
                            return target[prop].apply(this, args);
                        };
                    }
                    else {
                        return Reflect.get(target, prop, receiver);
                    }
                },
                set(target, prop, value) {
                    if (prop === 'onabort') {
                        signalHandled = true;
                    }
                    return Reflect.set(target, prop, value);
                },
                deleteProperty(target, prop) {
                    if (prop === 'onabort') {
                        signalHandled = true;
                    }
                    return Reflect.deleteProperty(target, prop);
                },
            });
            signalHandled = false;
        }
        let reject_;
        super((resolve, reject) => {
            reject_ = (reason) => {
                // This swaps the `DOMException [AbortError]` for `undefined`.
                // This is because we expect aborting or cancelling with `undefined`
                // should mean rejection of `undefined`.
                if (reason instanceof DOMException && reason.name === 'AbortError') {
                    reason = undefined;
                }
                reject(reason);
            };
            executor(resolve, reject_, signal);
        });
        if (!signalHandled) {
            abortController.signal.addEventListener('abort', () => {
                reject_(abortController.signal.reason);
            }, { once: true });
        }
        this.reject = reject_;
        this.abortController = abortController;
    }
    get [Symbol.toStringTag]() {
        return this.constructor.name;
    }
    cancel(reason) {
        this.abortController.abort(reason);
    }
    then(onFulfilled, onRejected, controller) {
        // eslint-disable-next-line prefer-const
        let signal;
        let onFulfilled_;
        let onRejected_;
        if (typeof onFulfilled === 'function') {
            onFulfilled_ = (value) => onFulfilled(value, signal);
        }
        if (typeof onRejected === 'function') {
            onRejected_ = (reason) => onRejected(reason, signal);
        }
        // The `super.then` uses `Symbol.species`, and it is a native promise
        const p = super.then(onFulfilled_, onRejected_);
        const pC = PromiseCancellable.from(p, controller);
        signal = pC.abortController.signal;
        return pC;
    }
    catch(onRejected, controller) {
        // eslint-disable-next-line prefer-const
        let signal;
        let onRejected_;
        if (typeof onRejected === 'function') {
            onRejected_ = (reason) => onRejected(reason, signal);
        }
        // The `super.catch` calls `this.then`
        // so this is already a `PromiseCancellable`
        const pC = super.catch(onRejected_);
        if (typeof controller === 'function') {
            pC.abortController = new AbortController();
            controller(pC.abortController.signal);
        }
        else if (controller != null) {
            pC.abortController = controller;
        }
        signal = pC.abortController.signal;
        return pC;
    }
    finally(onFinally, controller) {
        // eslint-disable-next-line prefer-const
        let signal;
        let onFinally_;
        if (typeof onFinally === 'function') {
            onFinally_ = () => onFinally(signal);
        }
        // The `super.finally` calls `this.then`
        // so this is already a `PromiseCancellable`
        const pC = super.finally(onFinally_);
        if (typeof controller === 'function') {
            pC.abortController = new AbortController();
            controller(pC.abortController.signal);
        }
        else if (controller != null) {
            pC.abortController = controller;
        }
        signal = pC.abortController.signal;
        return pC;
    }
}
exports.default = PromiseCancellable;
//# sourceMappingURL=PromiseCancellable.js.map