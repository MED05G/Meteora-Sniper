import type { PromiseCancellableController } from './types';
declare class PromiseCancellable<T> extends Promise<T> {
    static get [Symbol.species](): PromiseConstructor;
    static resolve(): PromiseCancellable<void>;
    static resolve<T>(value: T | PromiseLike<T>): PromiseCancellable<T>;
    static reject<T = never>(reason?: any): PromiseCancellable<T>;
    static all<T extends readonly unknown[] | []>(values: T, controller?: PromiseCancellableController): PromiseCancellable<{
        -readonly [P in keyof T]: Awaited<T[P]>;
    }>;
    static all<T>(values: Iterable<T | PromiseLike<T>>, controller?: PromiseCancellableController): PromiseCancellable<Awaited<T>[]>;
    static allSettled<T extends readonly unknown[] | []>(values: T, controller?: PromiseCancellableController): PromiseCancellable<{
        -readonly [P in keyof T]: PromiseSettledResult<Awaited<T[P]>>;
    }>;
    static allSettled<T>(values: Iterable<T | PromiseLike<T>>, controller?: PromiseCancellableController): PromiseCancellable<PromiseSettledResult<Awaited<T>>[]>;
    static race<T extends readonly unknown[] | []>(values: T, controller?: PromiseCancellableController): PromiseCancellable<Awaited<T[number]>>;
    static race<T>(values: Iterable<T | PromiseLike<T>>, controller?: PromiseCancellableController): PromiseCancellable<Awaited<T>>;
    static any<T extends readonly unknown[] | []>(values: T, controller?: PromiseCancellableController): PromiseCancellable<Awaited<T[number]>>;
    static any<T>(values: Iterable<T | PromiseLike<T>>, controller?: PromiseCancellableController): PromiseCancellable<Awaited<T>>;
    static from<T>(p: PromiseLike<T>, controller?: PromiseCancellableController): PromiseCancellable<T>;
    protected readonly reject: (reason?: any) => void;
    protected abortController: AbortController;
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, signal: AbortSignal) => void, controller?: PromiseCancellableController);
    get [Symbol.toStringTag](): string;
    cancel(reason?: any): void;
    then<TResult1 = T, TResult2 = never>(onFulfilled?: ((value: T, signal: AbortSignal) => TResult1 | PromiseLike<TResult1>) | undefined | null, onRejected?: ((reason: any, signal: AbortSignal) => TResult2 | PromiseLike<TResult2>) | undefined | null, controller?: PromiseCancellableController): PromiseCancellable<TResult1 | TResult2>;
    catch<TResult = never>(onRejected?: ((reason: any, signal: AbortSignal) => TResult | PromiseLike<TResult>) | undefined | null, controller?: PromiseCancellableController): PromiseCancellable<T | TResult>;
    finally(onFinally?: ((signal: AbortSignal) => void) | undefined | null, controller?: PromiseCancellableController): PromiseCancellable<T>;
}
export default PromiseCancellable;
