/// <reference types="node" />
/// <reference types="node" />
import type { ReadableWritablePair, ReadableStreamDefaultController, WritableStreamDefaultController } from 'stream/web';
import type QUICConnection from './QUICConnection';
import type { QUICConfig, ConnectionMetadata, StreamId, StreamReasonToCode, StreamCodeToReason } from './types';
import { ReadableStream, WritableStream } from 'stream/web';
import Logger from '@matrixai/logger';
import { CreateDestroy } from '@matrixai/async-init/dist/CreateDestroy';
import * as events from './events';
interface QUICStream extends CreateDestroy {
}
declare class QUICStream implements ReadableWritablePair<Uint8Array, Uint8Array> {
    /**
     * Creates a QUIC stream.
     *
     * This creation is synchronous as it avoids the need for concurrent locking
     * for generating new stream IDs.
     *
     * @param opts
     * @param opts.initiated - local or peer initiated stream
     * @param opts.streamId - stream ID
     * @param opts.connection - QUIC connection
     * @param opts.config - QUIC config
     * @param opts.reasonToCode - maps stream error reasons to stream error codes
     * @param opts.codeToReason - maps stream error codes to reasons
     * @param opts.logger
     *
     * The `reasonToCode` defaults to returning `0` as the code.
     * The `codeToReason` defaults to returning `Error` instance.
     */
    static createQUICStream({ initiated, streamId, connection, config, reasonToCode, codeToReason, logger, }: {
        initiated: 'local' | 'peer';
        streamId: StreamId;
        connection: QUICConnection;
        config: QUICConfig;
        reasonToCode?: StreamReasonToCode;
        codeToReason?: StreamCodeToReason;
        logger?: Logger;
    }): QUICStream;
    readonly type: 'bidi' | 'uni';
    readonly initiated: 'local' | 'peer';
    readonly streamId: StreamId;
    readonly readable: ReadableStream<Uint8Array>;
    readonly writable: WritableStream<Uint8Array>;
    readonly closedP: Promise<void>;
    protected logger: Logger;
    protected connection: QUICConnection;
    protected reasonToCode: StreamReasonToCode;
    protected codeToReason: StreamCodeToReason;
    protected readableController: ReadableStreamDefaultController;
    protected writableController: WritableStreamDefaultController;
    protected _readClosed: boolean;
    protected _writeClosed: boolean;
    protected readableChunk?: Buffer;
    protected resolveReadableP?: () => void;
    protected rejectReadableP?: (reason?: any) => void;
    protected resolveWritableP?: () => void;
    protected rejectWritableP?: (reason?: any) => void;
    protected resolveClosedP: () => void;
    /**
     * Handles `EventQUICStreamError`.
     *
     * This event propagates all errors relating to locally cancelling or aborting
     * the readable or writable, or receiving a `RESET_STREAM` or `STOP_SENDING`
     * on the readable or writable respectively.
     *
     * Internal errors will be thrown upwards to become an uncaught exception.
     *
     * @throws {errors.ErrorQUICStreamInternal}
     */
    protected handleEventQUICStreamError: (evt: events.EventQUICStreamError) => void;
    /**
     * Handles `EventQUICStreamCloseRead`.
     * Registered once.
     */
    protected handleEventQUICStreamCloseRead: () => Promise<void>;
    /**
     * Handles `EventQUICStreamCloseWrite`.
     * Registered once.
     */
    protected handleEventQUICStreamCloseWrite: () => Promise<void>;
    constructor({ initiated, streamId, connection, config, reasonToCode, codeToReason, logger, }: {
        initiated: 'local' | 'peer';
        streamId: StreamId;
        connection: QUICConnection;
        config: QUICConfig;
        reasonToCode: StreamReasonToCode;
        codeToReason: StreamCodeToReason;
        logger: Logger;
    });
    /**
     * Returns true of the writable has closed.
     */
    get writeClosed(): boolean;
    /**
     * Returns true if the readable has closed.
     */
    get readClosed(): boolean;
    get meta(): ConnectionMetadata;
    get closed(): boolean;
    /**
     * Destroy the QUIC stream.
     *
     * @param opts
     * @param opts.force - if true, this will cancel readable and abort writable.
     * @param opts.reason - the reason to send to the peer, and if readable and
     *                      writable is cancelled and aborted, then this will be
     *                      the readable and writable error.
     *
     * @throws {errors.ErrorQUICStreamInternal} - if cancel fails
     */
    destroy({ force, reason, }?: {
        force?: boolean;
        reason?: any;
    }): Promise<void>;
    /**
     * Cancels the readable and aborts the writable.
     *
     * If streams have already closed or cancelled then this will do nothing.
     * If the underlying quiche streams already closed then this will do nothing.
     *
     * Cancellation will occur in the background.
     *
     * @throws {errors.ErrorQUICStreamInternal} - if cancel fails
     */
    cancel(reason?: any): void;
    protected readableStart(controller: ReadableStreamDefaultController): void;
    protected writableStart(controller: WritableStreamDefaultController): void;
    /**
     * Serialised by `ReadableStream`.
     *
     * @throws {errors.ErrorQUICStreamInternal}
     */
    protected readablePull(): Promise<void>;
    /**
     * Serialised with `this.writableClose` by `WritableStream`.
     *
     * @throws {errors.ErrorQUICStreamInternal}
     */
    protected writableWrite(chunk: Uint8Array): Promise<void>;
    /**
     * Serialised with `this.writableWrite` by `WritableStream`.
     *
     * @throws {errors.ErrorQUICStreamInternal}
     */
    protected writableClose(): void;
    /**
     * `ReadableStream` ensures that this method is idempotent
     *
     * @throws {errors.ErrorQUICStreamInternal}
     */
    protected readableCancel(reason?: any): void;
    /**
     * `WritableStream` ensures that this method is idempotent.
     *
     * @throws {errors.ErrorQUICStreamInternal}
     */
    protected writableAbort(reason?: any): void;
}
export default QUICStream;
