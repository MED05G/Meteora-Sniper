/// <reference types="node" />
import type { Host, Port, QUICServerCrypto, ResolveHostname, QUICConfig, QUICServerConfigInput, StreamCodeToReason, StreamReasonToCode } from './types';
import Logger from '@matrixai/logger';
import { EventAll } from '@matrixai/events';
import { StartStop } from '@matrixai/async-init/dist/StartStop';
import QUICSocket from './QUICSocket';
import QUICConnectionId from './QUICConnectionId';
import { ConnectionErrorCode } from './native';
import * as events from './events';
interface QUICServer extends StartStop {
}
declare class QUICServer {
    /**
     * Determines if socket is shared.
     */
    readonly isSocketShared: boolean;
    /**
     * Custom reason to code converter for new connections.
     */
    reasonToCode?: StreamReasonToCode;
    /**
     * Custom code to reason converted for new connections.
     */
    codeToReason?: StreamCodeToReason;
    /**
     * The minimum idle timeout to be used for new connections.
     */
    minIdleTimeout?: number;
    protected logger: Logger;
    protected socket: QUICSocket;
    protected crypto: QUICServerCrypto;
    protected config: QUICConfig;
    protected _closed: boolean;
    protected _closedP: Promise<void>;
    protected resolveClosedP: () => void;
    protected stopAbortController: AbortController | undefined;
    /**
     * Handles `EventQUICServerError`.
     *
     * Internal errors will be thrown upwards to become an uncaught exception.
     *
     * @throws {errors.ErrorQUICServerInternal}
     */
    protected handleEventQUICServerError: (evt: events.EventQUICServerError) => void;
    /**
     * Handles `EventQUICServerClose`.
     * Registered once.
     *
     * This event propagates errors minus the internal errors.
     *
     * If this event is dispatched first before `QUICServer.stop`, it represents
     * an evented close. This could originate from the `QUICSocket`. If it was
     * from the `QUICSocket`, then here it will stop all connections with an
     * transport code `InternalError`.
     */
    protected handleEventQUICServerClose: (evt: events.EventQUICServerClose) => Promise<void>;
    /**
     * Handles all `EventQUICSocket` events.
     * Registered only if the socket is encapsulated.
     */
    protected handleEventQUICSocket: (evt: EventAll) => void;
    /**
     * Handles `EventQUICSocketStopped`.
     * Registered once.
     *
     * It is an error if the socket was stopped while `QUICServer` wasn't
     * stopped.
     */
    protected handleEventQUICSocketStopped: () => void;
    /**
     * Handles all `EventQUICConnection` events.
     */
    protected handleEventQUICConnection: (evt: EventAll) => void;
    /**
     * Handles `EventQUICConnectionSend`.
     *
     * This will propagate the connection send buffers to the socket.
     * This may be concurrent and multiple send events may be processed
     * at a time.
     */
    protected handleEventQUICConnectionSend: (evt: events.EventQUICConnectionSend) => Promise<void>;
    /**
     * Handles `EventQUICConnectionStopped`.
     * Registered once.
     */
    protected handleEventQUICConnectionStopped: (evt: events.EventQUICConnectionStopped) => void;
    /**
     * Constructs a QUIC server.
     *
     * @param opts
     * @param opts.crypto - server needs to be able to sign and verify symmetrically.
     * @param opts.config - defaults to `serverDefault`
     * @param opts.socket - optional shared QUICSocket
     * @param opts.resolveHostname - defaults to using OS DNS resolver
     * @param opts.reasonToCode - maps stream error reasons to stream error codes
     * @param opts.codeToReason - maps stream error codes to reasons
     * @param opts.minIdleTimeout - can be set to override the starting timeout
     *                              for accepted connections
     * @param opts.logger
     */
    constructor(opts: {
        crypto: QUICServerCrypto;
        config: QUICServerConfigInput;
        resolveHostname?: ResolveHostname;
        reasonToCode?: StreamReasonToCode;
        codeToReason?: StreamCodeToReason;
        minIdleTimeout?: number;
        logger?: Logger;
    });
    constructor(opts: {
        crypto: QUICServerCrypto;
        config: QUICServerConfigInput;
        socket: QUICSocket;
        reasonToCode?: StreamReasonToCode;
        codeToReason?: StreamCodeToReason;
        minIdleTimeout?: number;
        logger?: Logger;
    });
    get host(): Host;
    get port(): Port;
    /**
     * Server is no longer accepting connections.
     */
    get closed(): boolean;
    get closedP(): Promise<void>;
    /**
     * Starts the QUICServer.
     *
     * @param opts
     * @param opts.host - target host, ignored if socket is shared
     * @param opts.port - target port, ignored if socket is shared
     * @param opts.reuseAddr - reuse existing port
     * @param opts.ipv6Only - force using IPv6 even when using `::`
     */
    start({ host, port, reuseAddr, ipv6Only, }?: {
        host?: string;
        port?: number;
        reuseAddr?: boolean;
        ipv6Only?: boolean;
    }): Promise<void>;
    /**
     * Stops the QUICServer.
     *
     * @param opts
     * @param opts.isApp - whether the stop is initiated by the application
     * @param opts.errorCode - the error code to send to the peers
     * @param opts.reason - the reason to send to the peers
     * @param opts.force - force controls whether to cancel streams or wait for
     *                     streams to close gracefully
     */
    stop({ isApp, errorCode, reason, force, }?: {
        isApp: false;
        errorCode?: ConnectionErrorCode;
        reason?: Uint8Array;
        force?: boolean;
    } | {
        isApp?: true;
        errorCode?: number;
        reason?: Uint8Array;
        force?: boolean;
    }): Promise<void>;
    updateCrypto(crypto: Partial<QUICServerCrypto>): void;
    /**
     * Updates the `QUICConfig` for new connections.
     * It will not affect existing connections, they will keep using the old
     * `QUICConfig`.
     */
    updateConfig(config: Partial<QUICServerConfigInput>): void;
    /**
     * Creates a retry token.
     * This will embed peer host IP and DCID into the token.
     * It will authenticate the data by providing a signature signed by our key.
     */
    protected mintToken(dcid: QUICConnectionId, peerHost: Host): Promise<Buffer>;
    /**
     * Validates the retry token.
     * This will check that the token was signed by us.
     * And it will check that the current host IP is the same as the one put into the token.
     * This proves that the peer can in fact receive and send from the host IP.
     * This returns the DCID inside the token, which was the original DCID.
     */
    protected validateToken(tokenBuffer: Buffer, peerHost: Host): Promise<QUICConnectionId | undefined>;
}
export default QUICServer;
