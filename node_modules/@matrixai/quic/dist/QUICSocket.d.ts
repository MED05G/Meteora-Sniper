/// <reference types="node" />
/// <reference types="node" />
import type QUICServer from './QUICServer';
import type { Host, Port, ResolveHostname } from './types';
import dgram from 'dgram';
import Logger from '@matrixai/logger';
import { StartStop } from '@matrixai/async-init/dist/StartStop';
import * as events from './events';
interface QUICSocket extends StartStop {
}
declare class QUICSocket {
    protected logger: Logger;
    /**
     * Registered server for this socket.
     * If a server is not registered for this socket, all packets for new
     * connections will be dropped.
     */
    protected server?: QUICServer;
    /**
     * Hostname resolver.
     */
    protected resolveHostname: ResolveHostname;
    protected _host: Host;
    protected _port: Port;
    protected _type: 'ipv4' | 'ipv6' | 'ipv4&ipv6';
    protected _closed: boolean;
    protected _closedP: Promise<void>;
    protected resolveClosedP: () => void;
    protected socket: dgram.Socket;
    protected socketBind: (port: number, host: string) => Promise<void>;
    protected socketClose: () => Promise<void>;
    protected socketSend: (...params: Array<any>) => Promise<number>;
    protected handleEventQUICSocketError: (evt: events.EventQUICSocketError) => void;
    protected handleEventQUICSocketClose: () => Promise<void>;
    /**
     * Handles UDP socket message.
     *
     * The `data` buffer could be multiple coalesced QUIC packets.
     * It could also be a non-QUIC packet data.
     * If it is non-QUIC, we can discard the data.
     * If there are multiple coalesced QUIC packets, it is expected that
     * all packets are intended for the same connection. This means we only
     * need to parse the first QUIC packet to determining what connection to route
     * the data to.
     */
    protected handleSocketMessage: (data: Buffer, remoteInfo: dgram.RemoteInfo) => Promise<void>;
    /**
     * Constructs a QUIC socket.
     *
     * @param opts
     * @param opts.resolveHostname - defaults to using OS DNS resolver
     * @param opts.logger
     */
    constructor({ resolveHostname, logger, }: {
        resolveHostname?: ResolveHostname;
        logger?: Logger;
    });
    /**
     * Gets the bound resolved host IP (not hostname).
     * This can be the IPv4 or IPv6 address.
     * This could be a wildcard address which means all interfaces.
     * Note that `::` can mean all IPv4 and all IPv6.
     * Whereas `0.0.0.0` means only all IPv4.
     */
    get host(): Host;
    /**
     * Gets the bound resolved port.
     * This cannot be `0`.
     * Because `0` is always resolved to a specific port.
     */
    get port(): Port;
    /**
     * Gets the type of socket
     * It can be ipv4-only, ipv6-only or dual stack
     */
    get type(): 'ipv4' | 'ipv6' | 'ipv4&ipv6';
    get closed(): boolean;
    get closedP(): Promise<void>;
    /**
     * Starts this QUICSocket.
     * This supports hostnames and IPv4 and IPv6 addresses.
     * If the host is `::`, this will also bind to `0.0.0.0`.
     *
     * @param opts
     * @param opts.host - The host to bind to. Default is `::`.
     * @param opts.port - The port to bind to. Default is `0`.
     * @param opts.reuseAddr - Whether to reuse the address. Default is `false`.
     * @param opts.ipv6Only - Whether to only bind to IPv6. Default is `false`.
     *
     * @throws {errors.ErrorQUICSocketInvalidBindAddress} If bind failed due to
     * EINVAL or ENOTFOUND. EINVAL is due to using IPv4 host when creating a
     * `udp6` socket. ENOTFOUND is when the hostname does not resolve
     * or does not resolve to IPv6 when creating a `udp6` socket or does not
     * resolve to IPv4 when creating a `udp4` socket.
     */
    start({ host, port, reuseAddr, ipv6Only, }?: {
        host?: string;
        port?: number;
        reuseAddr?: boolean;
        ipv6Only?: boolean;
    }): Promise<void>;
    /**
     * Stop this QUICSocket.
     *
     * @param opts
     * @param opts.force - Stop the socket even if the connection map is not empty.
     *
     * @throws {errors.ErrorQUICSocketConnectionsActive}
     */
    stop({ force, }?: {
        force?: boolean;
    }): Promise<void>;
    /**
     * Sends UDP datagram.
     * Because UDP socket is connectionless, the port and address are required.
     * This call is used internally by the rest of the library, but it is not
     * internal because it can be used for hole punching, which is an application
     * concern. Therefore if this method throws an exception, it does necessarily
     * mean that this `QUICSocket` is an error state. It could be the caller's
     * fault.
     */
    send(msg: string | Uint8Array | ReadonlyArray<any>, port: number, address: string): Promise<number>;
    send(msg: string | Uint8Array, offset: number, length: number, port: number, address: string): Promise<number>;
    send_(msg: string | Uint8Array, offset: number, length: number, port: number, address: string): Promise<number>;
    setServer(server: QUICServer): void;
    unsetServer(): void;
}
export default QUICSocket;
