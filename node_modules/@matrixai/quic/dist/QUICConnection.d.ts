import type { PromiseCancellable } from '@matrixai/async-cancellable';
import type { ContextTimedInput } from '@matrixai/contexts';
import type QUICSocket from './QUICSocket';
import type { Host, Port, RemoteInfo, QUICConfig, ConnectionMetadata, StreamId, StreamCodeToReason, StreamReasonToCode } from './types';
import type { ConnectionError } from './native/types';
import Logger from '@matrixai/logger';
import { Timer } from '@matrixai/timer';
import { Lock } from '@matrixai/async-locks';
import { EventAll } from '@matrixai/events';
import { StartStop } from '@matrixai/async-init/dist/StartStop';
import QUICConnectionId from './QUICConnectionId';
import QUICStream from './QUICStream';
import { ConnectionErrorCode } from './native';
import * as events from './events';
import * as errors from './errors';
interface QUICConnection extends StartStop {
}
declare class QUICConnection {
    /**
     * This determines when it is a client or server connection.
     */
    readonly type: 'client' | 'server';
    /**
     * Resolves once the connection has closed.
     */
    readonly closedP: Promise<void>;
    /**
     * Unique id used to identify events intended for this connection.
     */
    readonly sendId: string;
    protected logger: Logger;
    protected socket: QUICSocket;
    protected config: QUICConfig;
    protected reasonToCode: StreamReasonToCode;
    protected codeToReason: StreamCodeToReason;
    /**
     * This ensures that `recv` is serialised.
     * Prevents a new `recv` call intercepting the previous `recv` call that is
     * still finishing up with a `send` call.
     */
    protected recvLock: Lock;
    /**
     * Client initiated bidirectional stream starts at 0.
     * Increment by 4 to get the next ID.
     */
    protected streamIdClientBidi: StreamId;
    /**
     * Server initiated bidirectional stream starts at 1.
     * Increment by 4 to get the next ID.
     */
    protected streamIdServerBidi: StreamId;
    /**
     * Client initiated unidirectional stream starts at 2.
     * Increment by 4 to get the next ID.
     */
    protected streamIdClientUni: StreamId;
    /**
     * Server initiated unidirectional stream starts at 3.
     * Increment by 4 to get the next ID.
     */
    protected streamIdServerUni: StreamId;
    /**
     * Tracks the highest StreamId that has a created QUICStream for clientBidi
     */
    protected streamIdUsedClientBidi: StreamId;
    /**
     * Tracks the highest StreamId that has a created QUICStream for serverBidi
     */
    protected streamIdUsedServerBidi: StreamId;
    /**
     * Tracks the highest StreamId that has a created QUICStream for clientUni
     */
    protected streamIdUsedClientUni: StreamId;
    /**
     * Tracks the highest StreamId that has a created QUICStream for clientUni
     */
    protected streamIdUsedServerUni: StreamId;
    /**
     * Tracks used ids that have skipped the expected next id for the streamIdUsed counters.
     * If the next id in the streamIdUsed sequence is used then we remove IDs from the Set
     * up to the next ID gap.
     */
    protected streamIdUsedSet: Set<number>;
    /**
     * Quiche connection timer. This performs time delayed state transitions.
     */
    protected connTimeoutTimer?: Timer;
    /**
     * Keep alive timer.
     *
     * Quiche does not natively ensure activity on the connection. This interval
     * timer guarantees that there will be activity on the connection by sending
     * acknowlegement eliciting frames, which will cause the peer to acknowledge.
     *
     * This is still useful even if the `config.maxIdleTimeout` is set to 0, which
     * means the connection will never timeout due to being idle.
     *
     * This mechanism will only start working after `secureEstablishedP`.
     */
    protected keepAliveIntervalTimer?: Timer;
    /**
     * Remote host which can change on every `QUICConnection.recv`.
     */
    protected _remoteHost: Host;
    /**
     * Remote port which can change on every `QUICConnection.recv`.
     */
    protected _remotePort: Port;
    /**
     * Chain of local certificates from leaf to root in DER format.
     */
    protected certDERs: Array<Uint8Array>;
    /**
     * Array of independent CA certificates in DER format.
     */
    protected caDERs: Array<Uint8Array>;
    /**
     * Secure connection establishment means that this connection has completed
     * peer certificate verification, and the connection is ready to be used.
     */
    protected secureEstablished: boolean;
    /**
     * Resolves after connection is established and peer certs have been verified.
     */
    protected secureEstablishedP: Promise<void>;
    protected resolveSecureEstablishedP: () => void;
    protected rejectSecureEstablishedP: (reason?: any) => void;
    protected resolveClosedP: () => void;
    /**
     * Stores the last dispatched error. If no error, it will be `null`.
     *
     * `QUICConnection.stop` will need this if it is called by the user concurrent
     * with handling `EventQUICConnectionError`. It ensures that `this.stop` uses
     * the original error when force destroying the streams.
     */
    protected errorLast: errors.ErrorQUICConnectionLocal<unknown> | errors.ErrorQUICConnectionPeer<unknown> | errors.ErrorQUICConnectionIdleTimeout<unknown> | errors.ErrorQUICConnectionInternal<unknown> | null;
    /**
     * Handle `EventQUICConnectionError`.
     *
     * QUIC connections always close with errors. Graceful errors are logged out
     * at INFO level, while non-graceful errors are logged out at ERROR level.
     *
     * Internal errors will be thrown upwards to become an uncaught exception.
     *
     * @throws {errors.ErrorQUICConnectionInternal}
     */
    protected handleEventQUICConnectionError: (evt: events.EventQUICConnectionError) => void;
    /**
     * Handles `EventQUICConnectionClose`.
     * Registered once.
     *
     * This event means that `this.conn.close()` is already called.
     * It does not mean that `this.closedP` is resolved. The resolving of
     * `this.closedP` depends on the `this.connTimeoutTimer`.
     */
    protected handleEventQUICConnectionClose: (evt: events.EventQUICConnectionClose) => Promise<void>;
    /**
     * Handles all `EventQUICStream` events.
     */
    protected handleEventQUICStream: (evt: EventAll) => void;
    /**
     * Handles `EventQUICStreamSend`.
     *
     * This handler will trigger `this.send` when there is data in the writable
     * stream buffer. As this is asynchronous, it is necessary to check if this
     * `QUICConnection` is still running.
     */
    protected handleEventQUICStreamSend: () => Promise<void>;
    /**
     * Handles `EventQUICStreamDestroyed`.
     * Registered once.
     */
    protected handleEventQUICStreamDestroyed: (evt: events.EventQUICStreamDestroyed) => void;
    /**
     * Constructs a QUIC connection.
     *
     * @param opts
     * @param opts.type - client or server connection
     * @param opts.scid - source connection ID
     * @param opts.dcid - destination connection ID
     * @param opts.serverName - client connections can use server name for
     *                          verifying the server's certificate, however if
     *                          `config.verifyCallback` is set, this will have no
     *                          effect
     * @param opts.remoteInfo - remote host and port
     * @param opts.config - QUIC config
     * @param opts.socket - injected socket
     * @param opts.reasonToCode - maps stream error reasons to stream error codes
     * @param opts.codeToReason - maps stream error codes to reasons
     * @param opts.logger
     *
     * @throws {errors.ErrorQUICConnectionConfigInvalid}
     */
    constructor({ type, scid, dcid, serverName, remoteInfo, config, socket, reasonToCode, codeToReason, logger, }: {
        type: 'client';
        scid: QUICConnectionId;
        dcid?: void;
        serverName?: string | null;
        remoteInfo: RemoteInfo;
        config: QUICConfig;
        socket: QUICSocket;
        reasonToCode?: StreamReasonToCode;
        codeToReason?: StreamCodeToReason;
        logger?: Logger;
    } | {
        type: 'server';
        scid: QUICConnectionId;
        dcid: QUICConnectionId;
        serverName?: void;
        remoteInfo: RemoteInfo;
        config: QUICConfig;
        socket: QUICSocket;
        reasonToCode?: StreamReasonToCode;
        codeToReason?: StreamCodeToReason;
        logger?: Logger;
    });
    /**
     * This is the source connection ID.
     */
    get connectionId(): QUICConnectionId;
    /**
     * This is the destination connection ID.
     * This is only fully known after establishing the connection
     */
    get connectionIdPeer(): QUICConnectionId;
    /**
     * A common ID between the client and server connection.
     * Used to identify connection pairs more easily.
     */
    get connectionIdShared(): QUICConnectionId;
    get remoteHost(): Host;
    get remotePort(): Port;
    get localHost(): Host;
    get localPort(): Port;
    get closed(): boolean;
    /**
     * Starts the QUIC connection.
     *
     * This will complete the handshake and verify the peer's certificate.
     * The connection will be ready to be used after this resolves. The peer's
     * verification of the local certificate occurs concurrently.
     *
     * @param opts
     * @param opts.data - server connections receive initial data
     * @param opts.remoteInfo - server connections receive remote host and port
     * @param ctx - timed context overrides `config.minIdleTimeout` which only
     *              works if `config.maxIdleTimeout` is greater than
     *              `config.minIdleTimeout`
     *
     * @throws {errors.ErrorQUICConnectionStartTimeout} - if timed out due to `ctx.timer` or `config.minIdleTimeout`
     * @throws {errors.ErrorQUICConnectionStartData} - if no initial data for server connection
     * @throws {errors.ErrorQUICConnection} - all other connection failure errors
     */
    start(opts?: {
        data?: Uint8Array;
        remoteInfo?: RemoteInfo;
    }, ctx?: Partial<ContextTimedInput>): PromiseCancellable<void>;
    /**
     * Stops the QUIC connection.
     *
     * @param opts
     * @param opts.isApp - whether the destroy is initiated by the application
     * @param opts.errorCode - the error code to send to the peer, use
     *                         `ConnectionErrorCode` if `isApp` is false,
     *                         otherwise any unsigned integer is fine.
     * @param opts.reason - the reason to send to the peer
     * @param opts.force - force controls whether to cancel streams or wait for
     *                     streams to close gracefully
     *
     * The provided error parameters is only used if the quiche connection is not
     * draining or closed.
     */
    stop({ isApp, errorCode, reason, force, }?: {
        isApp: false;
        errorCode?: ConnectionErrorCode;
        reason?: Uint8Array;
        force?: boolean;
    } | {
        isApp?: true;
        errorCode?: number;
        reason?: Uint8Array;
        force?: boolean;
    }): Promise<void>;
    /**
     * Get connection error.
     * This could be `undefined` if connection timed out.
     */
    getConnectionError(): ConnectionError | undefined;
    /**
     * Array of independent CA certificates in DER format.
     */
    getLocalCACertsChain(): Array<Uint8Array>;
    /**
     * Chain of local certificates from leaf to root in DER format.
     */
    getLocalCertsChain(): Array<Uint8Array>;
    /**
     * Chain of remote certificates from leaf to root in DER format.
     */
    getRemoteCertsChain(): Array<Uint8Array>;
    meta(): ConnectionMetadata;
    protected isStreamUsed(streamId: StreamId): boolean;
    protected processStreams(): void;
    /**
     * Sets up the connection timeout timer.
     *
     * This only gets called on the first `QUICConnection.send`.
     * It's the responsiblity of this timer to resolve the `closedP`.
     */
    protected setConnTimeoutTimer(): void;
    /**
     * Creates a new QUIC stream on the connection.
     */
    newStream(type?: 'bidi' | 'uni'): QUICStream;
    /**
     * Destroys all active streams without closing the connection.
     *
     * If there are no active streams then it will do nothing.
     * If the connection is stopped with `force: false` then this can be used
     * to force close any streams `stop` is waiting for to end.
     *
     * Destruction will occur in the background.
     */
    destroyStreams(reason?: any): void;
    /**
     * Starts the keep alive interval timer.
     *
     * Interval time should be less than `maxIdleTimeout` unless it is `0`, which
     * means `Infinity`.
     *
     * If the `maxIdleTimeout` is `0`, this can still be useful to maintain
     * activity on the connection.
     */
    protected startKeepAliveIntervalTimer(ms: number): void;
    /**
     * Stops the keep alive interval timer
     */
    protected stopKeepAliveIntervalTimer(): void;
}
export default QUICConnection;
