"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const QUICConnectionId_1 = __importDefault(require("./QUICConnectionId"));
class QUICConnectionMap {
    [Symbol.toStringTag] = 'QUICConnectionMap';
    _serverConnections = new Map();
    _clientConnections = new Map();
    constructor(connections) {
        if (connections != null) {
            for (const [connectionId, connection] of connections) {
                this.set(connectionId, connection);
            }
        }
    }
    get size() {
        return this._serverConnections.size + this._clientConnections.size;
    }
    /**
     * Gets the server connections.
     * This uses `ConnectionIdString` because it is too complex to map
     * `ConnectionId` to `ConnectionIdString` and back.
     */
    get serverConnections() {
        return this._serverConnections;
    }
    /**
     * Gets the client connections.
     * This uses `ConnectionIdString` because it is too complex to map
     * `ConnectionId` to `ConnectionIdString` and back.
     */
    get clientConnections() {
        return this._clientConnections;
    }
    has(connectionId) {
        return (this._serverConnections.has(connectionId.toString()) ||
            this._clientConnections.has(connectionId.toString()));
    }
    get(connectionId) {
        return (this._serverConnections.get(connectionId.toString()) ??
            this._clientConnections.get(connectionId.toString()));
    }
    set(connectionId, connection) {
        if (connection.type === 'server') {
            this._serverConnections.set(connectionId.toString(), connection);
        }
        else if (connection.type === 'client') {
            this._clientConnections.set(connectionId.toString(), connection);
        }
        return this;
    }
    delete(connectionId) {
        return (this._serverConnections.delete(connectionId.toString()) ||
            this._clientConnections.delete(connectionId.toString()));
    }
    clear() {
        this._serverConnections.clear();
        this._clientConnections.clear();
    }
    forEach(callback, thisArg) {
        this._serverConnections.forEach((value, key) => {
            callback.bind(thisArg)(value, QUICConnectionId_1.default.fromString(key), this);
        });
        this._clientConnections.forEach((value, key) => {
            callback.bind(thisArg)(value, QUICConnectionId_1.default.fromString(key), this);
        });
    }
    [Symbol.iterator]() {
        const serverIterator = this._serverConnections[Symbol.iterator]();
        const clientIterator = this._clientConnections[Symbol.iterator]();
        const iterator = {
            next: () => {
                const serverResult = serverIterator.next();
                if (!serverResult.done) {
                    const [key, value] = serverResult.value;
                    return {
                        done: false,
                        value: [QUICConnectionId_1.default.fromString(key), value],
                    };
                }
                const clientResult = clientIterator.next();
                if (!clientResult.done) {
                    const [key, value] = clientResult.value;
                    return {
                        done: false,
                        value: [QUICConnectionId_1.default.fromString(key), value],
                    };
                }
                return { done: true, value: undefined };
            },
            [Symbol.iterator]: () => iterator,
        };
        return iterator;
    }
    entries() {
        return this[Symbol.iterator]();
    }
    keys() {
        const iterator = {
            next: () => {
                const result = this[Symbol.iterator]().next();
                if (!result.done) {
                    return {
                        done: false,
                        value: result.value[0],
                    };
                }
                return { done: true, value: undefined };
            },
            [Symbol.iterator]: () => iterator,
        };
        return iterator;
    }
    values() {
        const iterator = {
            next: () => {
                const result = this[Symbol.iterator]().next();
                if (!result.done) {
                    return {
                        done: false,
                        value: result.value[1],
                    };
                }
                return { done: true, value: undefined };
            },
            [Symbol.iterator]: () => iterator,
        };
        return iterator;
    }
}
exports.default = QUICConnectionMap;
//# sourceMappingURL=QUICConnectionMap.js.map