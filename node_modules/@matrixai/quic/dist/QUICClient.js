"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@matrixai/logger"));
const events_1 = require("@matrixai/events");
const async_init_1 = require("@matrixai/async-init");
const CreateDestroy_1 = require("@matrixai/async-init/dist/CreateDestroy");
const decorators_1 = require("@matrixai/contexts/dist/decorators");
const QUICSocket_1 = __importDefault(require("./QUICSocket"));
const QUICConnection_1 = __importDefault(require("./QUICConnection"));
const QUICConnectionId_1 = __importDefault(require("./QUICConnectionId"));
const native_1 = require("./native");
const config_1 = require("./config");
const utils = __importStar(require("./utils"));
const events = __importStar(require("./events"));
const errors = __importStar(require("./errors"));
let QUICClient = class QUICClient {
    static async createQUICClient({ host, port, serverName, localHost = '::', localPort = 0, socket, crypto, config = {}, resolveHostname = utils.resolveHostname, reuseAddr, ipv6Only, reasonToCode, codeToReason, logger = new logger_1.default(`${this.name}`), }, ctx) {
        let address = utils.buildAddress(host, port);
        logger.info(`Create ${this.name} to ${address}`);
        const quicConfig = {
            ...config_1.clientDefault,
            ...config,
        };
        // SCID for the client is randomly generated
        // DCID is also randomly generated, but by the quiche library
        const scidBuffer = new ArrayBuffer(native_1.quiche.MAX_CONN_ID_LEN);
        await crypto.ops.randomBytes(scidBuffer);
        const scid = new QUICConnectionId_1.default(scidBuffer);
        // Validating host and port types
        let [host_, udpType] = await utils.resolveHost(host, resolveHostname);
        const port_ = utils.toPort(port);
        // If the target host is in fact a zero IP, it cannot be used
        // as a target host, so we need to resolve it to a non-zero IP
        // in this case, 0.0.0.0 is resolved to 127.0.0.1 and :: and ::0 is
        // resolved to ::1.
        host_ = utils.resolvesZeroIP(host_);
        let isSocketShared;
        if (socket == null) {
            const [localHost_] = await utils.resolveHost(localHost, resolveHostname);
            const localPort_ = utils.toPort(localPort);
            socket = new QUICSocket_1.default({
                resolveHostname,
                logger: logger.getChild(QUICSocket_1.default.name),
            });
            isSocketShared = false;
            await socket.start({
                host: localHost_,
                port: localPort_,
                reuseAddr,
                ipv6Only,
            });
        }
        else {
            isSocketShared = true;
            // If the socket is shared, it must already be started
            if (!socket[async_init_1.running]) {
                throw new errors.ErrorQUICServerSocketNotRunning();
            }
        }
        try {
            // Check that the target `host` is compatible with the bound socket host
            // Also transform it if need be
            host_ = utils.validateTarget(socket.host, socket.type, host_, udpType, errors.ErrorQUICClientInvalidHost);
        }
        catch (e) {
            if (!isSocketShared) {
                await socket.stop({ force: true });
            }
            throw e;
        }
        let connection;
        try {
            connection = new QUICConnection_1.default({
                type: 'client',
                scid,
                serverName: serverName ?? host,
                socket,
                remoteInfo: {
                    host: host_,
                    port: port_,
                },
                config: quicConfig,
                reasonToCode,
                codeToReason,
                logger: logger.getChild(`${QUICConnection_1.default.name} ${scid.toString()}`),
            });
        }
        catch (e) {
            if (!isSocketShared) {
                await socket.stop({ force: true });
            }
            throw e;
        }
        const client = new this({
            socket,
            connection,
            isSocketShared,
            logger,
        });
        if (!isSocketShared) {
            socket.addEventListener(events_1.EventAll.name, client.handleEventQUICSocket);
        }
        socket.addEventListener(events.EventQUICSocketStopped.name, client.handleEventQUICSocketStopped, { once: true });
        connection.addEventListener(events_1.EventAll.name, client.handleEventQUICConnection);
        connection.addEventListener(events.EventQUICConnectionError.name, client.handleEventQUICConnectionError);
        connection.addEventListener(events.EventQUICConnectionSend.name, client.handleEventQUICConnectionSend);
        connection.addEventListener(events.EventQUICConnectionStopped.name, client.handleEventQUICConnectionStopped, { once: true });
        client.addEventListener(events.EventQUICClientError.name, client.handleEventQUICClientError);
        client.addEventListener(events.EventQUICClientClose.name, client.handleEventQUICClientClose, { once: true });
        // We have to start the connection after associating the event listeners on
        // the client, because the client bridges the push flow from the connection
        // to the socket.
        socket.connectionMap.set(connection.connectionId, connection);
        // Set up intermediate abort signal
        const abortController = new AbortController();
        const abortHandler = () => {
            abortController.abort(ctx.signal.reason);
        };
        if (ctx.signal.aborted)
            abortController.abort(ctx.signal.reason);
        else
            ctx.signal.addEventListener('abort', abortHandler);
        const handleEventQUICClientErrorSend = (evt) => {
            // @ts-ignore: the error contains `code` but not part of the type
            const code = evt.detail.code;
            switch (code) {
                // Thrown due to invalid arguments on linux
                case 'EINVAL':
                // Thrown due to invalid arguments on macOS
                // Falls through
                case 'EADDRNOTAVAIL':
                // Thrown due to invalid arguments on Win but also for network dropouts on all platforms
                // Falls through
                case 'ENETUNREACH':
                    {
                        abortController.abort(new errors.ErrorQUICClientInvalidArgument(undefined, {
                            cause: evt.detail,
                        }));
                    }
                    break;
                default: // Do nothing
            }
        };
        client.addEventListener(`${events.EventQUICClientErrorSend.name}-${connection.sendId}`, handleEventQUICClientErrorSend);
        try {
            await connection.start(undefined, {
                timer: ctx.timer,
                signal: abortController.signal,
            });
        }
        catch (e) {
            socket.connectionMap.delete(connection.connectionId);
            socket.removeEventListener(events.EventQUICSocketStopped.name, client.handleEventQUICSocketStopped);
            if (!isSocketShared) {
                socket.removeEventListener(events_1.EventAll.name, client.handleEventQUICSocket);
                await socket.stop({ force: true });
            }
            connection.removeEventListener(events_1.EventAll.name, client.handleEventQUICConnection);
            connection.removeEventListener(events.EventQUICConnectionError.name, client.handleEventQUICConnectionError);
            connection.removeEventListener(events.EventQUICConnectionSend.name, client.handleEventQUICConnectionSend);
            connection.removeEventListener(events.EventQUICConnectionStopped.name, client.handleEventQUICConnectionStopped);
            client.removeEventListener(events.EventQUICClientError.name, client.handleEventQUICClientError);
            client.removeEventListener(events.EventQUICClientClose.name, client.handleEventQUICClientClose);
            throw e;
        }
        finally {
            ctx.signal.removeEventListener('abort', abortHandler);
            client.removeEventListener(`${events.EventQUICClientErrorSend.name}-${connection.sendId}`, handleEventQUICClientErrorSend);
        }
        address = utils.buildAddress(host_, port);
        logger.info(`Created ${this.name} to ${address}`);
        return client;
    }
    isSocketShared;
    connection;
    closedP;
    logger;
    socket;
    config;
    _closed = false;
    resolveClosedP;
    /**
     * Handles `EventQUICClientError`.
     *
     * This event propagates all errors from `QUICClient` and `QUICConnection`.
     * This means you can expect that `QUICConnection` errors will be logged
     * twice.
     *
     * Internal errors will be thrown upwards to become an uncaught exception.
     *
     * @throws {errors.ErrorQUICClientInternal}
     * @throws {errors.ErrorQUICConnectionInternal}
     */
    handleEventQUICClientError = (evt) => {
        const error = evt.detail;
        // Log out the error
        this.logger.info(utils.formatError(error));
        if (error instanceof errors.ErrorQUICClientInternal ||
            error instanceof errors.ErrorQUICConnectionInternal) {
            throw error;
        }
        this.dispatchEvent(new events.EventQUICClientClose({
            detail: error,
        }));
    };
    /**
     * Handles `EventQUICClientClose`.
     * Registered once.
     *
     * This event propagates errors minus the internal errors.
     * All QUIC connections always close with an error, even if it is a graceful.
     *
     * If this event is dispatched first before `QUICClient.destroy`, it represents
     * an evented close. This could originate from the `QUICSocket` or
     * `QUICConnection`. If it was from the `QUICSocket`, then here it will stop
     * the `QUICConnection` with an transport code `InternalError`. If it was
     * from `QUICConnection`, then the `QUICConnection` will already be closing.
     * Therefore attempting to stop the `QUICConnection` will be idempotent.
     */
    handleEventQUICClientClose = async (evt) => {
        const error = evt.detail;
        // Remove the error listener as we intend to stop the connection
        this.connection.removeEventListener(events.EventQUICConnectionError.name, this.handleEventQUICConnectionError);
        await this.connection.stop({
            isApp: false,
            errorCode: native_1.ConnectionErrorCode.InternalError,
            reason: Buffer.from(error.description),
            force: true,
        });
        if (!(error instanceof errors.ErrorQUICClientSocketNotRunning)) {
            // Only stop the socket if it was encapsulated
            if (!this.isSocketShared) {
                // Remove the stopped listener, as we intend to stop the socket
                this.socket.removeEventListener(events.EventQUICSocketStopped.name, this.handleEventQUICSocketStopped);
                try {
                    // Force stop of the socket even if it had a connection map
                    // This is because we will be stopping this `QUICClient` which
                    // which will stop all the relevant connections
                    await this.socket.stop({ force: true });
                }
                catch (e) {
                    const e_ = new errors.ErrorQUICClientInternal('Failed to stop QUICSocket', { cause: e });
                    this.dispatchEvent(new events.EventQUICClientError({ detail: e_ }));
                }
            }
        }
        this._closed = true;
        this.resolveClosedP();
        if (!this[CreateDestroy_1.destroyed] && this[CreateDestroy_1.status] !== 'destroying') {
            await this.destroy({ force: true });
        }
    };
    /**
     * Handles all `EventQUICSocket` events.
     * Registered only if the socket is encapsulated.
     */
    handleEventQUICSocket = (evt) => {
        if (evt.detail instanceof events_1.AbstractEvent &&
            // Avoid cloning the `EventQUICConnectionSend` event as it's very low level
            !(evt.detail instanceof events.EventQUICConnectionSend)) {
            this.dispatchEvent(evt.detail.clone());
        }
    };
    /**
     * Handles `EventQUICSocketStopped`.
     * Registered once.
     *
     * It is an error if the socket was stopped while `QUICClient` wasn't
     * destroyed.
     */
    handleEventQUICSocketStopped = () => {
        const e = new errors.ErrorQUICClientSocketNotRunning();
        this.removeEventListener(events_1.EventAll.name, this.handleEventQUICSocket);
        this.dispatchEvent(new events.EventQUICClientError({
            detail: e,
        }));
    };
    /**
     * Handles all `EventQUICConnection` events.
     */
    handleEventQUICConnection = (evt) => {
        if (evt.detail instanceof events_1.AbstractEvent) {
            this.dispatchEvent(evt.detail.clone());
        }
    };
    /**
     * Handles `EventQUICConnectionError`.
     *
     * All connection errors are redispatched as client errors.
     */
    handleEventQUICConnectionError = (evt) => {
        const error = evt.detail;
        this.dispatchEvent(new events.EventQUICClientError({ detail: error }));
    };
    /**
     * Handles `EventQUICConnectionSend`.
     *
     * This will propagate the connection send buffers to the socket.
     * This may be concurrent and multiple send events may be processed
     * at a time.
     */
    handleEventQUICConnectionSend = async (evt) => {
        try {
            if (!(this.socket[async_init_1.running] && this.socket[CreateDestroy_1.status] !== 'stopping'))
                return;
            // Uses the raw send method as the port and address is fully resolved
            // and determined by `QUICConnection`.
            await this.socket.send_(evt.detail.msg, evt.detail.port, evt.detail.address);
        }
        catch (e) {
            switch (e.code) {
                // Thrown due to invalid arguments on linux
                case 'EINVAL':
                // Thrown due to invalid arguments on macOS
                // Falls through
                case 'EADDRNOTAVAIL':
                // Thrown due to invalid arguments on Win but also for network dropouts on all platforms
                // Falls through
                case 'ENETUNREACH':
                // Thrown when no route to the host is available.
                // Falls through
                case 'EHOSTUNREACH':
                    {
                        this.dispatchEvent(new events.EventQUICClientErrorSend(`${events.EventQUICClientErrorSend.name}-${evt.detail.id}`, {
                            detail: e,
                        }));
                    }
                    break;
                default:
                    {
                        this.dispatchEvent(new events.EventQUICClientError({
                            detail: new errors.ErrorQUICClientInternal('Failed to send data on the QUICSocket', {
                                data: evt.detail,
                                cause: e,
                            }),
                        }));
                    }
                    break;
            }
        }
    };
    /**
     * Handles `EventQUICConnectionStopped`.
     * Registered once.
     */
    handleEventQUICConnectionStopped = (evt) => {
        const quicConnection = evt.target;
        quicConnection.removeEventListener(events.EventQUICConnectionError.name, this.handleEventQUICConnectionError);
        quicConnection.removeEventListener(events.EventQUICConnectionSend.name, this.handleEventQUICConnectionSend);
        quicConnection.removeEventListener(events_1.EventAll.name, this.handleEventQUICConnection);
        this.socket.connectionMap.delete(quicConnection.connectionId);
    };
    constructor({ socket, isSocketShared, connection, logger, }) {
        this.logger = logger;
        this.socket = socket;
        this.isSocketShared = isSocketShared;
        this.connection = connection;
        const { p: closedP, resolveP: resolveClosedP } = utils.promise();
        this.closedP = closedP;
        this.resolveClosedP = resolveClosedP;
    }
    get host() {
        return this.connection.remoteHost;
    }
    get port() {
        return this.connection.remotePort;
    }
    get localHost() {
        return this.socket.host;
    }
    get localPort() {
        return this.socket.port;
    }
    get closed() {
        return this._closed;
    }
    /**
     * Destroy the QUICClient.
     *
     * @param opts
     * @param opts.isApp - whether the destroy is initiated by the application
     * @param opts.errorCode - the error code to send to the peer
     * @param opts.reason - the reason to send to the peer
     * @param opts.force - force controls whether to cancel streams or wait for
     *                     streams to close gracefully
     */
    async destroy({ isApp = true, errorCode = 0, reason = new Uint8Array(), force = true, } = {}) {
        let address;
        if (this.connection[async_init_1.running]) {
            address = utils.buildAddress(this.connection.remoteHost, this.connection.remotePort);
        }
        this.logger.info(`Destroy ${this.constructor.name}${address != null ? ` to ${address}` : ''}`);
        if (!this._closed) {
            await this.connection.stop({
                isApp,
                errorCode,
                reason,
                force,
            });
        }
        await this.closedP;
        this.removeEventListener(events.EventQUICClientError.name, this.handleEventQUICClientError);
        this.removeEventListener(events.EventQUICClientClose.name, this.handleEventQUICClientClose);
        // The socket may not have been stopped if it is shared
        // In which case we just remove our listener here
        this.socket.removeEventListener(events.EventQUICSocketStopped.name, this.handleEventQUICSocketStopped);
        if (!this.isSocketShared) {
            this.socket.removeEventListener(events_1.EventAll.name, this.handleEventQUICSocket);
        }
        // Connection listeners do not need to be removed
        // Because it is handled by `this.handleEventQUICConnectionStopped`.
        this.logger.info(`Destroyed ${this.constructor.name}${address != null ? ` to ${address}` : ''}`);
    }
};
__decorate([
    (0, CreateDestroy_1.ready)(new errors.ErrorQUICClientDestroyed())
], QUICClient.prototype, "host", null);
__decorate([
    (0, CreateDestroy_1.ready)(new errors.ErrorQUICClientDestroyed())
], QUICClient.prototype, "port", null);
__decorate([
    (0, CreateDestroy_1.ready)(new errors.ErrorQUICClientDestroyed())
], QUICClient.prototype, "localHost", null);
__decorate([
    (0, CreateDestroy_1.ready)(new errors.ErrorQUICClientDestroyed())
], QUICClient.prototype, "localPort", null);
__decorate([
    (0, decorators_1.timedCancellable)(true, config_1.minIdleTimeout, errors.ErrorQUICClientCreateTimeout),
    __param(1, decorators_1.context)
], QUICClient, "createQUICClient", null);
QUICClient = __decorate([
    (0, CreateDestroy_1.CreateDestroy)({
        eventDestroy: events.EventQUICClientDestroy,
        eventDestroyed: events.EventQUICClientDestroyed,
    })
], QUICClient);
exports.default = QUICClient;
//# sourceMappingURL=QUICClient.js.map