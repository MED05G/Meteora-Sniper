"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMaxListeners = exports.isStreamReset = exports.isStreamStopped = exports.isStreamUnidirectional = exports.isStreamBidirectional = exports.isStreamServerInitiated = exports.isStreamClientInitiated = exports.validateToken = exports.mintToken = exports.decodeConnectionId = exports.encodeConnectionId = exports.formatError = exports.derToPEM = exports.pemToDER = exports.collectPEMs = exports.validateTarget = exports.buildAddress = exports.toPort = exports.isPort = exports.resolveHost = exports.resolveHostname = exports.resolvesZeroIP = exports.toCanonicalIP = exports.isHostWildcard = exports.fromIPv4MappedIPv6 = exports.toIPv4MappedIPv6Hex = exports.toIPv4MappedIPv6Dec = exports.isIPv4MappedIPv6Dec = exports.isIPv4MappedIPv6Hex = exports.isIPv4MappedIPv6 = exports.isIPv6 = exports.isIPv4 = exports.bufferWrap = exports.promise = exports.promisify = exports.yieldMicro = exports.never = exports.textDecoder = exports.textEncoder = void 0;
const dns_1 = __importDefault(require("dns"));
const events_1 = __importDefault(require("events"));
const ip_num_1 = require("ip-num");
const QUICConnectionId_1 = __importDefault(require("./QUICConnectionId"));
const errors = __importStar(require("./errors"));
const textEncoder = new TextEncoder();
exports.textEncoder = textEncoder;
const textDecoder = new TextDecoder('utf-8');
exports.textDecoder = textDecoder;
function never(message) {
    throw new errors.ErrorQUICUndefinedBehaviour(message);
}
exports.never = never;
/**
 * Used to yield to the event loop to allow other micro tasks to process
 */
async function yieldMicro() {
    return await new Promise((r) => queueMicrotask(r));
}
exports.yieldMicro = yieldMicro;
/**
 * Convert callback-style to promise-style
 * If this is applied to overloaded function
 * it will only choose one of the function signatures to use
 */
function promisify(f) {
    // Uses a regular function so that `this` can be bound
    return function (...params) {
        return new Promise((resolve, reject) => {
            const callback = (error, ...values) => {
                if (error != null) {
                    return reject(error);
                }
                if (values.length === 0) {
                    resolve();
                }
                else if (values.length === 1) {
                    resolve(values[0]);
                }
                else {
                    resolve(values);
                }
                return;
            };
            params.push(callback);
            f.apply(this, params);
        });
    };
}
exports.promisify = promisify;
/**
 * Deconstructed promise
 */
function promise() {
    let resolveP, rejectP;
    const p = new Promise((resolve, reject) => {
        resolveP = resolve;
        rejectP = reject;
    });
    return {
        p,
        resolveP,
        rejectP,
    };
}
exports.promise = promise;
/**
 * Zero-copy wraps ArrayBuffer-like objects into Buffer
 * This supports ArrayBuffer, TypedArrays and the NodeJS Buffer
 */
function bufferWrap(array, offset, length) {
    if (Buffer.isBuffer(array)) {
        return array;
    }
    else if (ArrayBuffer.isView(array)) {
        return Buffer.from(array.buffer, offset ?? array.byteOffset, length ?? array.byteLength);
    }
    else {
        return Buffer.from(array, offset, length);
    }
}
exports.bufferWrap = bufferWrap;
/**
 * Is it an IPv4 address?
 */
function isIPv4(host) {
    const [isIPv4] = ip_num_1.Validator.isValidIPv4String(host);
    return isIPv4;
}
exports.isIPv4 = isIPv4;
/**
 * Is it an IPv6 address?
 * This considers IPv4 mapped IPv6 addresses to also be IPv6 addresses.
 */
function isIPv6(host) {
    const [isIPv6] = ip_num_1.Validator.isValidIPv6String(host);
    if (isIPv6)
        return true;
    // Test if the host is an IPv4 mapped IPv6 address.
    // In the future, `isValidIPv6String` should be able to handle this
    // and this code can be removed.
    return isIPv4MappedIPv6(host);
}
exports.isIPv6 = isIPv6;
/**
 * There are 2 kinds of IPv4 mapped IPv6 addresses.
 * 1. ::ffff:127.0.0.1 - dotted decimal version
 * 2. ::ffff:7f00:1 - hex version
 * Both are accepted by Node's dgram module.
 */
function isIPv4MappedIPv6(host) {
    if (host.startsWith('::ffff:')) {
        try {
            // The `ip-num` package understands `::ffff:7f00:1`
            ip_num_1.IPv6.fromString(host);
            return true;
        }
        catch {
            // But it does not understand `::ffff:127.0.0.1`
            const ipv4 = host.slice('::ffff:'.length);
            if (isIPv4(ipv4)) {
                return true;
            }
        }
    }
    return false;
}
exports.isIPv4MappedIPv6 = isIPv4MappedIPv6;
function isIPv4MappedIPv6Hex(host) {
    if (host.startsWith('::ffff:')) {
        try {
            // The `ip-num` package understands `::ffff:7f00:1`
            ip_num_1.IPv6.fromString(host);
            return true;
        }
        catch {
            return false;
        }
    }
    return false;
}
exports.isIPv4MappedIPv6Hex = isIPv4MappedIPv6Hex;
function isIPv4MappedIPv6Dec(host) {
    if (host.startsWith('::ffff:')) {
        // But it does not understand `::ffff:127.0.0.1`
        const ipv4 = host.slice('::ffff:'.length);
        if (isIPv4(ipv4)) {
            return true;
        }
    }
    return false;
}
exports.isIPv4MappedIPv6Dec = isIPv4MappedIPv6Dec;
/**
 * Takes an IPv4 address and returns the IPv4 mapped IPv6 address.
 * This produces the dotted decimal variant.
 */
function toIPv4MappedIPv6Dec(host) {
    if (!isIPv4(host)) {
        throw new TypeError('Invalid IPv4 address');
    }
    return ('::ffff:' + host);
}
exports.toIPv4MappedIPv6Dec = toIPv4MappedIPv6Dec;
/**
 * Takes an IPv4 address and returns the IPv4 mapped IPv6 address.
 * This produces the dotted Hexidecimal variant.
 */
function toIPv4MappedIPv6Hex(host) {
    if (!isIPv4(host)) {
        throw new TypeError('Invalid IPv4 address');
    }
    return ip_num_1.IPv4.fromString(host).toIPv4MappedIPv6().toString();
}
exports.toIPv4MappedIPv6Hex = toIPv4MappedIPv6Hex;
/**
 * Extracts the IPv4 portion out of the IPv4 mapped IPv6 address.
 * Can handle both the dotted decimal and hex variants.
 * 1. ::ffff:7f00:1
 * 2. ::ffff:127.0.0.1
 * Always returns the dotted decimal variant.
 */
function fromIPv4MappedIPv6(host) {
    const ipv4 = host.slice('::ffff:'.length);
    if (isIPv4(ipv4)) {
        return ipv4;
    }
    const matches = ipv4.match(/^([0-9a-fA-F]{1,4}):([0-9a-fA-F]{1,4})$/);
    if (matches == null) {
        throw new TypeError('Invalid IPv4 mapped IPv6 address');
    }
    const ipv4Hex = matches[1].padStart(4, '0') + matches[2].padStart(4, '0');
    const ipv4Hexes = ipv4Hex.match(/.{1,2}/g);
    const ipv4Decs = ipv4Hexes.map((h) => parseInt(h, 16));
    return ipv4Decs.join('.');
}
exports.fromIPv4MappedIPv6 = fromIPv4MappedIPv6;
function isHostWildcard(host) {
    return (host === '0.0.0.0' ||
        host === '::' ||
        host === '::0' ||
        host === '::ffff:0.0.0.0' ||
        host === '::ffff:0:0');
}
exports.isHostWildcard = isHostWildcard;
/**
 * This converts all `IPv4` formats to the `IPv4` decimal format.
 * `IPv4` decimal and `IPv6` hex formatted IPs are left unchanged.
 */
function toCanonicalIP(host) {
    if (isIPv4MappedIPv6(host)) {
        return fromIPv4MappedIPv6(host);
    }
    if (isIPv4(host) || isIPv6(host)) {
        return host;
    }
    throw new TypeError('Invalid IP address');
}
exports.toCanonicalIP = toCanonicalIP;
/**
 * Zero IPs should be resolved to localhost when used as the target
 */
function resolvesZeroIP(host) {
    const zeroIPv4 = new ip_num_1.IPv4('0.0.0.0');
    // This also covers `::0`
    const zeroIPv6 = new ip_num_1.IPv6('::');
    if (isIPv4MappedIPv6(host)) {
        const ipv4 = fromIPv4MappedIPv6(host);
        if (new ip_num_1.IPv4(ipv4).isEquals(zeroIPv4)) {
            return toIPv4MappedIPv6Dec('127.0.0.1');
        }
        else {
            return host;
        }
    }
    else if (isIPv4(host) && new ip_num_1.IPv4(host).isEquals(zeroIPv4)) {
        return '127.0.0.1';
    }
    else if (isIPv6(host) && new ip_num_1.IPv6(host).isEquals(zeroIPv6)) {
        return '::1';
    }
    else {
        return host;
    }
}
exports.resolvesZeroIP = resolvesZeroIP;
/**
 * This will resolve a hostname to the first host.
 * It could be an IPv6 address or IPv4 address.
 * This uses the OS's DNS resolution system.
 */
async function resolveHostname(hostname) {
    const result = await dns_1.default.promises.lookup(hostname, {
        family: 0,
        all: false,
        verbatim: true,
    });
    return result.address;
}
exports.resolveHostname = resolveHostname;
/**
 * This will resolve a Host or Hostname to Host and `udp4` or `udp6`.
 * The `resolveHostname` can be overridden.
 */
async function resolveHost(host, resolveHostname) {
    if (isIPv4(host)) {
        return [host, 'udp4'];
    }
    else if (isIPv6(host)) {
        return [host, 'udp6'];
    }
    else {
        try {
            host = await resolveHostname(host);
            return resolveHost(host, resolveHostname);
        }
        catch {
            throw new errors.ErrorQUICHostInvalid();
        }
    }
}
exports.resolveHost = resolveHost;
/**
 * Is it a valid Port?
 */
function isPort(port) {
    if (typeof port !== 'number')
        return false;
    return port >= 0 && port <= 65535;
}
exports.isPort = isPort;
/**
 * Throws if port is invalid, otherwise returns port as Port.
 */
function toPort(port) {
    if (!isPort(port))
        throw new errors.ErrorQUICPortInvalid();
    return port;
}
exports.toPort = toPort;
/**
 * Given host and port, create an address string.
 */
function buildAddress(host, port = 0) {
    let address;
    if (isIPv4(host)) {
        address = `${host}:${port}`;
    }
    else if (isIPv6(host)) {
        address = `[${host}]:${port}`;
    }
    else {
        address = `${host}:${port}`;
    }
    return address;
}
exports.buildAddress = buildAddress;
function validateTarget(socketHost, socketType, targetHost, targetUdpType, errorClass) {
    if (isHostWildcard(targetHost)) {
        throw new errorClass(`Invalid wildcard target host ${targetHost}`);
    }
    const isSocketHostIPv4Mapped = isIPv4MappedIPv6(socketHost);
    const isTargetHostIPv4Mapped = isIPv4MappedIPv6(targetHost);
    if (socketType === 'ipv4&ipv6' && targetUdpType === 'udp4') {
        // If socket is IPv4 and IPv6 then:
        //   If target is IPv4 - wrap and pass
        //   If target is IPv6 - pass
        //   If target is IPv4 mapped IPv6 - pass
        return toIPv4MappedIPv6Dec(targetHost);
    }
    if (socketType === 'ipv4') {
        if (!isSocketHostIPv4Mapped) {
            // If socket is IPv4 then:
            //   if target is IPv4 - pass
            //   if target is IPv6 - fail
            //   if target is IPv4 mapped IPv6 - unwrap and pass
            if (targetUdpType === 'udp6') {
                if (isTargetHostIPv4Mapped) {
                    return fromIPv4MappedIPv6(targetHost);
                }
                else {
                    throw new errorClass(`Invalid target host ${targetHost} from an IPv4 socket`);
                }
            }
        }
        else {
            // If socket is IPv4 but uses IPv4 mapped IPv6 bound address then:
            //   If target is IPv4 - wrap and pass
            //   If target is IPv6 - fail
            //   If target is IPv4 mapped IPv6 - pass
            if (targetUdpType === 'udp4') {
                return toIPv4MappedIPv6Dec(targetHost);
            }
            else if (targetUdpType === 'udp6' && !isTargetHostIPv4Mapped) {
                throw new errorClass(`Invalid target host ${targetHost} from an IPv4 socket`);
            }
        }
        return targetHost;
    }
    if (socketType === 'ipv6') {
        // If socket is IPv6 then:
        //   If target is IPv4 - fail
        //   If target is IPv6 - pass
        //   If target is IPv4 mapped IPv6 - fail
        if (targetUdpType === 'udp4' || isTargetHostIPv4Mapped) {
            throw new errorClass(`Invalid target host ${targetHost} from an IPv6 socket`);
        }
        return targetHost;
    }
    return targetHost;
}
exports.validateTarget = validateTarget;
/**
 * Collects PEM arrays specified in `QUICConfig` into a PEM chain array.
 * This can be used for keys, certs and ca.
 */
function collectPEMs(pems) {
    const pemsChain = [];
    if (typeof pems === 'string') {
        pemsChain.push(pems.trim() + '\n');
    }
    else if (pems instanceof Uint8Array) {
        pemsChain.push(textDecoder.decode(pems).trim() + '\n');
    }
    else if (Array.isArray(pems)) {
        for (const c of pems) {
            if (typeof c === 'string') {
                pemsChain.push(c.trim() + '\n');
            }
            else {
                pemsChain.push(textDecoder.decode(c).trim() + '\n');
            }
        }
    }
    return pemsChain;
}
exports.collectPEMs = collectPEMs;
/**
 * Converts PEM strings to DER Uint8Array
 */
function pemToDER(pem) {
    const pemB64 = pem
        .replace(/-----BEGIN .*-----/, '')
        .replace(/-----END .*-----/, '')
        .replace(/\s+/g, '');
    const der = Buffer.from(pemB64, 'base64');
    return new Uint8Array(der);
}
exports.pemToDER = pemToDER;
/**
 * Converts DER Uint8Array to PEM string
 */
function derToPEM(der) {
    const data = Buffer.from(der.buffer, der.byteOffset, der.byteLength);
    const contents = data
        .toString('base64')
        .replace(/(.{64})/g, '$1\n')
        .trimEnd() + '\n';
    return `-----BEGIN CERTIFICATE-----\n${contents}-----END CERTIFICATE-----\n`;
}
exports.derToPEM = derToPEM;
/**
 * Formats error exceptions.
 * Example: `Error: description - message`
 */
function formatError(error) {
    return `${error.name}${'description' in error ? `: ${error.description}` : ''}${error.message !== undefined ? ` - ${error.message}` : ''}`;
}
exports.formatError = formatError;
function encodeConnectionId(connId) {
    return connId.toString('hex');
}
exports.encodeConnectionId = encodeConnectionId;
function decodeConnectionId(connIdString) {
    return Buffer.from(connIdString, 'hex');
}
exports.decodeConnectionId = decodeConnectionId;
async function mintToken(dcid, peerHost, crypto) {
    const msgData = { dcid: dcid.toString(), host: peerHost };
    const msgJSON = JSON.stringify(msgData);
    const msgBuffer = Buffer.from(msgJSON);
    const msgSig = Buffer.from(await crypto.ops.sign(crypto.key, msgBuffer));
    const tokenData = {
        msg: msgBuffer.toString('base64url'),
        sig: msgSig.toString('base64url'),
    };
    const tokenJSON = JSON.stringify(tokenData);
    return Buffer.from(tokenJSON);
}
exports.mintToken = mintToken;
async function validateToken(tokenBuffer, peerHost, crypto) {
    let tokenData;
    try {
        tokenData = JSON.parse(tokenBuffer.toString());
    }
    catch {
        return;
    }
    if (typeof tokenData !== 'object' || tokenData == null) {
        return;
    }
    if (typeof tokenData.msg !== 'string' || typeof tokenData.sig !== 'string') {
        return;
    }
    const msgBuffer = Buffer.from(tokenData.msg, 'base64url');
    const msgSig = Buffer.from(tokenData.sig, 'base64url');
    if (!(await crypto.ops.verify(crypto.key, msgBuffer, msgSig))) {
        return;
    }
    let msgData;
    try {
        msgData = JSON.parse(msgBuffer.toString());
    }
    catch {
        return;
    }
    if (typeof msgData !== 'object' || msgData == null) {
        return;
    }
    if (typeof msgData.dcid !== 'string' || typeof msgData.host !== 'string') {
        return;
    }
    if (msgData.host !== peerHost) {
        return;
    }
    return QUICConnectionId_1.default.fromString(msgData.dcid);
}
exports.validateToken = validateToken;
function isStreamClientInitiated(streamId) {
    return (streamId & 0b01) === 0;
}
exports.isStreamClientInitiated = isStreamClientInitiated;
function isStreamServerInitiated(streamId) {
    return (streamId & 0b01) === 1;
}
exports.isStreamServerInitiated = isStreamServerInitiated;
function isStreamUnidirectional(streamId) {
    return (streamId & 0b10) !== 0;
}
exports.isStreamUnidirectional = isStreamUnidirectional;
function isStreamBidirectional(streamId) {
    return (streamId & 0b10) === 0;
}
exports.isStreamBidirectional = isStreamBidirectional;
/**
 * Note if the peer sends a corrupted `StreamStopped`, the `code` will be `NaN`
 * Furthermore it is limited to 16 digits the stringified maximum integer size of JS.
 */
function isStreamStopped(e) {
    let match;
    if ((match = e.message.match(/StreamStopped\((\d{1,16})\)/)) != null) {
        const code = parseInt(match[1]);
        return code;
    }
    else {
        return false;
    }
}
exports.isStreamStopped = isStreamStopped;
/**
 * Note if the peer sends a corrupted `StreamReset`, the `code` will be `NaN`
 * Furthermore it is limited to 16 digits the stringified maximum integer size of JS.
 */
function isStreamReset(e) {
    let match;
    if ((match = e.message.match(/StreamReset\((\d{1,16})\)/)) != null) {
        const code = parseInt(match[1]);
        return code;
    }
    else {
        return false;
    }
}
exports.isStreamReset = isStreamReset;
/**
 * Increases the total number of registered event handlers before a node warning is emitted.
 * In most cases this is not needed but in the case where you have one event emitter for multiple handlers you'll need
 * to increase the limit.
 * @param target - The specific `EventTarget` or `EventEmitter` to increase the warning for.
 * @param limit - The limit before the warning is emitted, defaults to 100000.
 */
function setMaxListeners(target, limit = 100000) {
    events_1.default.setMaxListeners(limit, target);
}
exports.setMaxListeners = setMaxListeners;
//# sourceMappingURL=utils.js.map