"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@matrixai/logger"));
const events_1 = require("@matrixai/events");
const StartStop_1 = require("@matrixai/async-init/dist/StartStop");
const QUICSocket_1 = __importDefault(require("./QUICSocket"));
const QUICConnection_1 = __importDefault(require("./QUICConnection"));
const QUICConnectionId_1 = __importDefault(require("./QUICConnectionId"));
const native_1 = require("./native");
const config_1 = require("./config");
const utils = __importStar(require("./utils"));
const events = __importStar(require("./events"));
const errors = __importStar(require("./errors"));
let QUICServer = class QUICServer {
    /**
     * Determines if socket is shared.
     */
    isSocketShared;
    /**
     * Custom reason to code converter for new connections.
     */
    reasonToCode;
    /**
     * Custom code to reason converted for new connections.
     */
    codeToReason;
    /**
     * The minimum idle timeout to be used for new connections.
     */
    minIdleTimeout;
    logger;
    socket;
    crypto;
    config;
    _closed = false;
    _closedP;
    resolveClosedP;
    // Used to abort any starting connections when the server stops
    stopAbortController;
    /**
     * Handles `EventQUICServerError`.
     *
     * Internal errors will be thrown upwards to become an uncaught exception.
     *
     * @throws {errors.ErrorQUICServerInternal}
     */
    handleEventQUICServerError = (evt) => {
        const error = evt.detail;
        // Log out error for debugging
        this.logger.info(utils.formatError(error));
        if (error instanceof errors.ErrorQUICServerInternal) {
            throw error;
        }
        this.dispatchEvent(new events.EventQUICServerClose({
            detail: error,
        }));
    };
    /**
     * Handles `EventQUICServerClose`.
     * Registered once.
     *
     * This event propagates errors minus the internal errors.
     *
     * If this event is dispatched first before `QUICServer.stop`, it represents
     * an evented close. This could originate from the `QUICSocket`. If it was
     * from the `QUICSocket`, then here it will stop all connections with an
     * transport code `InternalError`.
     */
    handleEventQUICServerClose = async (evt) => {
        const error = evt.detail;
        if (!(error instanceof errors.ErrorQUICServerSocketNotRunning)) {
            // Only stop the socket if it was encapsulated
            if (!this.isSocketShared) {
                // Remove the stopped listener, as we intend to stop the socket
                this.socket.removeEventListener(events.EventQUICSocketStopped.name, this.handleEventQUICSocketStopped);
                try {
                    // Force stop of the socket even if it had a connection map
                    // This is because we will be stopping this `QUICServer` which
                    // which will stop all the relevant connections
                    await this.socket.stop({ force: true });
                }
                catch (e) {
                    const e_ = new errors.ErrorQUICServerInternal('Failed to stop QUICSocket', { cause: e });
                    this.dispatchEvent(new events.EventQUICServerError({ detail: e_ }));
                }
            }
        }
        this._closed = true;
        this.resolveClosedP();
        if (this[StartStop_1.running] && this[StartStop_1.status] !== 'stopping') {
            if (error !== undefined) {
                await this.stop({
                    isApp: false,
                    errorCode: native_1.ConnectionErrorCode.InternalError,
                    reason: Buffer.from(error.description),
                    force: true,
                });
            }
            else {
                await this.stop({ force: true });
            }
        }
    };
    /**
     * Handles all `EventQUICSocket` events.
     * Registered only if the socket is encapsulated.
     */
    handleEventQUICSocket = (evt) => {
        if (evt.detail instanceof events_1.AbstractEvent) {
            this.dispatchEvent(evt.detail.clone());
        }
    };
    /**
     * Handles `EventQUICSocketStopped`.
     * Registered once.
     *
     * It is an error if the socket was stopped while `QUICServer` wasn't
     * stopped.
     */
    handleEventQUICSocketStopped = () => {
        const e = new errors.ErrorQUICServerSocketNotRunning();
        this.removeEventListener(events_1.EventAll.name, this.handleEventQUICSocket);
        this.dispatchEvent(new events.EventQUICServerError({
            detail: e,
        }));
    };
    /**
     * Handles all `EventQUICConnection` events.
     */
    handleEventQUICConnection = (evt) => {
        if (evt.detail instanceof events_1.AbstractEvent &&
            // Avoid cloning the `EventQUICConnectionSend` event as it's very low level
            !(evt.detail instanceof events.EventQUICConnectionSend)) {
            this.dispatchEvent(evt.detail.clone());
        }
    };
    /**
     * Handles `EventQUICConnectionSend`.
     *
     * This will propagate the connection send buffers to the socket.
     * This may be concurrent and multiple send events may be processed
     * at a time.
     */
    handleEventQUICConnectionSend = async (evt) => {
        // We want to skip this if the socket has already ended
        if (!(this.socket[StartStop_1.running] && this.socket[StartStop_1.status] !== 'stopping'))
            return;
        try {
            await this.socket.send_(evt.detail.msg, evt.detail.port, evt.detail.address);
        }
        catch (e) {
            switch (e.code) {
                // Thrown due to invalid arguments on linux
                case 'EINVAL':
                // Thrown due to invalid arguments on macOS
                // Falls through
                case 'EADDRNOTAVAIL':
                // Thrown due to invalid arguments on Win but also for network dropouts on all platforms
                // Falls through
                case 'ENETUNREACH':
                // Thrown when no route to the host is available.
                // Falls through
                case 'EHOSTUNREACH':
                    {
                        this.dispatchEvent(new events.EventQUICClientErrorSend(`${events.EventQUICClientErrorSend.name}-${evt.detail.id}`, {
                            detail: e,
                        }));
                    }
                    break;
                default:
                    {
                        this.dispatchEvent(new events.EventQUICServerError({
                            detail: new errors.ErrorQUICServerInternal('Failed to send data on the QUICSocket', {
                                data: evt.detail,
                                cause: e,
                            }),
                        }));
                    }
                    break;
            }
        }
    };
    /**
     * Handles `EventQUICConnectionStopped`.
     * Registered once.
     */
    handleEventQUICConnectionStopped = (evt) => {
        const quicConnection = evt.target;
        quicConnection.removeEventListener(events.EventQUICConnectionSend.name, this.handleEventQUICConnectionSend);
        quicConnection.removeEventListener(events_1.EventAll.name, this.handleEventQUICConnection);
        this.socket.connectionMap.delete(quicConnection.connectionId);
    };
    constructor({ crypto, config, socket, resolveHostname = utils.resolveHostname, reasonToCode, codeToReason, minIdleTimeout, logger, }) {
        this.logger = logger ?? new logger_1.default(this.constructor.name);
        this.crypto = crypto;
        if (socket == null) {
            this.socket = new QUICSocket_1.default({
                resolveHostname,
                logger: this.logger.getChild(QUICSocket_1.default.name),
            });
            this.isSocketShared = false;
        }
        else {
            this.socket = socket;
            this.isSocketShared = true;
        }
        this.config = {
            ...config_1.serverDefault,
            ...config,
        };
        this.reasonToCode = reasonToCode;
        this.codeToReason = codeToReason;
        this.minIdleTimeout = minIdleTimeout;
        const { p: closedP, resolveP: resolveClosedP } = utils.promise();
        this._closedP = closedP;
        this.resolveClosedP = resolveClosedP;
    }
    get host() {
        return this.socket.host;
    }
    get port() {
        return this.socket.port;
    }
    /**
     * Server is no longer accepting connections.
     */
    get closed() {
        return this._closed;
    }
    get closedP() {
        return this._closedP;
    }
    /**
     * Starts the QUICServer.
     *
     * @param opts
     * @param opts.host - target host, ignored if socket is shared
     * @param opts.port - target port, ignored if socket is shared
     * @param opts.reuseAddr - reuse existing port
     * @param opts.ipv6Only - force using IPv6 even when using `::`
     */
    async start({ host = '::', port = 0, reuseAddr, ipv6Only, } = {}) {
        this.stopAbortController = new AbortController();
        // Since we have a one-to-many relationship with clients and connections,
        // we want to up the warning limit on the stopAbortController
        utils.setMaxListeners(this.stopAbortController.signal);
        let address;
        if (!this.isSocketShared) {
            address = utils.buildAddress(host, port);
            this.logger.info(`Start ${this.constructor.name} on ${address}`);
            await this.socket.start({ host, port, reuseAddr, ipv6Only });
            address = utils.buildAddress(this.socket.host, this.socket.port);
        }
        else {
            // If the socket is shared, it must already be started
            if (!this.socket[StartStop_1.running]) {
                throw new errors.ErrorQUICServerSocketNotRunning();
            }
            address = utils.buildAddress(this.socket.host, this.socket.port);
            this.logger.info(`Start ${this.constructor.name} on ${address}`);
        }
        this.socket.setServer(this);
        this.addEventListener(events.EventQUICServerError.name, this.handleEventQUICServerError);
        this.addEventListener(events.EventQUICServerClose.name, this.handleEventQUICServerClose, { once: true });
        this.socket.addEventListener(events.EventQUICSocketStopped.name, this.handleEventQUICSocketStopped, { once: true });
        if (!this.isSocketShared) {
            this.socket.addEventListener(events_1.EventAll.name, this.handleEventQUICSocket);
        }
        this._closed = false;
        this.logger.info(`Started ${this.constructor.name} on ${address}`);
    }
    /**
     * Stops the QUICServer.
     *
     * @param opts
     * @param opts.isApp - whether the stop is initiated by the application
     * @param opts.errorCode - the error code to send to the peers
     * @param opts.reason - the reason to send to the peers
     * @param opts.force - force controls whether to cancel streams or wait for
     *                     streams to close gracefully
     */
    async stop({ isApp = true, errorCode = 0, reason = new Uint8Array(), force = true, } = {}) {
        let address;
        if (this.socket[StartStop_1.running]) {
            address = utils.buildAddress(this.socket.host, this.socket.port);
        }
        this.logger.info(`Stop ${this.constructor.name}${address != null ? ` on ${address}` : ''}`);
        // Stop answering new connections
        this.socket.unsetServer();
        const connectionsDestroyP = [];
        // If force then signal for any starting connections to abort
        if (force) {
            this.stopAbortController?.abort(new errors.ErrorQUICServerStopping());
        }
        this.stopAbortController = undefined;
        for (const connection of this.socket.connectionMap.serverConnections.values()) {
            connectionsDestroyP.push(connection.stop({
                isApp,
                errorCode,
                reason,
                force,
            }));
        }
        await Promise.all(connectionsDestroyP);
        if (!this._closed) {
            this.dispatchEvent(new events.EventQUICServerClose());
        }
        // Wait for the socket to be closed
        await this._closedP;
        // Resets the `closedP`
        const { p: closedP, resolveP: resolveClosedP } = utils.promise();
        this._closedP = closedP;
        this.resolveClosedP = resolveClosedP;
        this.removeEventListener(events.EventQUICServerError.name, this.handleEventQUICServerError);
        this.removeEventListener(events.EventQUICServerClose.name, this.handleEventQUICServerClose);
        // The socket may not have been stopped if it is shared
        // In which case we just remove our listener here
        this.socket.removeEventListener(events.EventQUICSocketStopped.name, this.handleEventQUICSocketStopped);
        if (!this.isSocketShared) {
            this.socket.removeEventListener(events_1.EventAll.name, this.handleEventQUICSocket);
        }
        this.logger.info(`Stopped ${this.constructor.name}${address != null ? ` on ${address}` : ''}`);
    }
    /**
     * Accepts new connection from the socket.
     *
     * This performs the new connection handshake.
     *
     * @internal
     */
    async acceptConnection(remoteInfo, header, dcid, data) {
        // If the packet is not an `Initial` nor `ZeroRTT` then we discard the
        // packet.
        if (header.ty !== native_1.quiche.Type.Initial &&
            header.ty !== native_1.quiche.Type.ZeroRTT) {
            return;
        }
        // Derive the new connection's SCID from the client generated DCID
        const scid = new QUICConnectionId_1.default(await this.crypto.ops.sign(this.crypto.key, dcid), 0, native_1.quiche.MAX_CONN_ID_LEN);
        const peerAddress = utils.buildAddress(remoteInfo.host, remoteInfo.port);
        // Version Negotiation
        if (!native_1.quiche.versionIsSupported(header.version)) {
            const versionDatagram = Buffer.allocUnsafe(native_1.quiche.MAX_DATAGRAM_SIZE);
            const versionDatagramLength = native_1.quiche.negotiateVersion(header.scid, header.dcid, versionDatagram);
            try {
                await this.socket.send_(versionDatagram, 0, versionDatagramLength, remoteInfo.port, remoteInfo.host);
            }
            catch (e) {
                // This is a caller error
                // Not a domain error for QUICServer
                throw new errors.ErrorQUICServerNewConnection(`Failed to send version datagram ${peerAddress}`, { cause: e });
            }
            return;
        }
        // At this point we are processing an `Initial` packet.
        // It is expected that token exists, because if it didn't, there would have
        // been a `BufferTooShort` error during parsing.
        const token = header.token;
        // Stateless Retry
        if (token.byteLength === 0) {
            const token = await this.mintToken(dcid, remoteInfo.host);
            const retryDatagram = Buffer.allocUnsafe(native_1.quiche.MAX_DATAGRAM_SIZE);
            const retryDatagramLength = native_1.quiche.retry(header.scid, // Client initial packet source ID
            header.dcid, // Client initial packet destination ID
            scid, // Server's new source ID that is derived
            token, header.version, retryDatagram);
            try {
                await this.socket.send_(retryDatagram, 0, retryDatagramLength, remoteInfo.port, remoteInfo.host);
            }
            catch (e) {
                throw new errors.ErrorQUICServerNewConnection(`Failed to send stateless retry datagram to ${peerAddress}`, { cause: e });
            }
            return;
        }
        // At this point in time, the packet's DCID is the originally-derived DCID.
        // While the DCID embedded in the token is the original DCID that the client first created.
        const dcidOriginal = await this.validateToken(Buffer.from(token), remoteInfo.host);
        if (dcidOriginal == null) {
            // Failed validation due to missing DCID
            return;
        }
        // Check that the newly-derived DCID (passed in as the SCID) is the same
        // length as the packet DCID.
        // This ensures that the derivation process hasn't changed.
        if (scid.byteLength !== header.dcid.byteLength) {
            // Failed validation due to mismatched length
            return;
        }
        // Here we shall re-use the originally-derived DCID as the SCID
        const newScid = new QUICConnectionId_1.default(header.dcid);
        // Construct a QUIC connection that isn't yet started
        const connection = new QUICConnection_1.default({
            type: 'server',
            scid: newScid,
            dcid: dcidOriginal,
            socket: this.socket,
            remoteInfo,
            config: { ...this.config },
            reasonToCode: this.reasonToCode,
            codeToReason: this.codeToReason,
            logger: this.logger.getChild(`${QUICConnection_1.default.name} ${scid.toString()}`),
        });
        // This unstarted connection is set to the connection map which allows
        // concurrent received packets to trigger the `recv` and `send` pair.
        this.socket.connectionMap.set(connection.connectionId, connection);
        connection.addEventListener(events.EventQUICConnectionSend.name, this.handleEventQUICConnectionSend);
        connection.addEventListener(events.EventQUICConnectionStopped.name, this.handleEventQUICConnectionStopped, { once: true });
        connection.addEventListener(events_1.EventAll.name, this.handleEventQUICConnection);
        try {
            await connection.start({
                data,
                remoteInfo,
            }, {
                timer: this.minIdleTimeout,
                signal: this.stopAbortController?.signal,
            });
        }
        catch (e) {
            connection.removeEventListener(events.EventQUICConnectionSend.name, this.handleEventQUICConnectionSend);
            connection.removeEventListener(events.EventQUICConnectionStopped.name, this.handleEventQUICConnectionStopped);
            connection.removeEventListener(events_1.EventAll.name, this.handleEventQUICConnection);
            this.socket.connectionMap.delete(connection.connectionId);
            // This could be due to a runtime IO exception or start timeout
            throw new errors.ErrorQUICServerNewConnection('Failed to start accepted connection', { cause: e });
        }
        // This connection is now started and ready to be used
        this.dispatchEvent(new events.EventQUICServerConnection({ detail: connection }));
        return connection;
    }
    updateCrypto(crypto) {
        this.crypto = {
            ...this.crypto,
            ...crypto,
        };
    }
    /**
     * Updates the `QUICConfig` for new connections.
     * It will not affect existing connections, they will keep using the old
     * `QUICConfig`.
     */
    updateConfig(config) {
        this.config = {
            ...this.config,
            ...config,
        };
    }
    /**
     * Creates a retry token.
     * This will embed peer host IP and DCID into the token.
     * It will authenticate the data by providing a signature signed by our key.
     */
    async mintToken(dcid, peerHost) {
        return utils.mintToken(dcid, peerHost, this.crypto);
    }
    /**
     * Validates the retry token.
     * This will check that the token was signed by us.
     * And it will check that the current host IP is the same as the one put into the token.
     * This proves that the peer can in fact receive and send from the host IP.
     * This returns the DCID inside the token, which was the original DCID.
     */
    async validateToken(tokenBuffer, peerHost) {
        return utils.validateToken(tokenBuffer, peerHost, this.crypto);
    }
};
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICServerNotRunning())
], QUICServer.prototype, "host", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICServerNotRunning())
], QUICServer.prototype, "port", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICServerNotRunning())
], QUICServer.prototype, "acceptConnection", null);
QUICServer = __decorate([
    (0, StartStop_1.StartStop)({
        eventStart: events.EventQUICServerStart,
        eventStarted: events.EventQUICServerStarted,
        eventStop: events.EventQUICServerStop,
        eventStopped: events.EventQUICServerStopped,
    })
], QUICServer);
exports.default = QUICServer;
//# sourceMappingURL=QUICServer.js.map