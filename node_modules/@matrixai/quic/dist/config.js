"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildQuicheConfig = exports.serverDefault = exports.clientDefault = exports.minIdleTimeout = void 0;
const native_1 = require("./native");
const utils = __importStar(require("./utils"));
const errors = __importStar(require("./errors"));
/**
 * BoringSSL does not support:
 * - rsa_pss_pss_sha256
 * - rsa_pss_pss_sha384
 * - rsa_pss_pss_sha512
 * - ed448
 */
const sigalgs = [
    'rsa_pkcs1_sha256',
    'rsa_pkcs1_sha384',
    'rsa_pkcs1_sha512',
    'rsa_pss_rsae_sha256',
    'rsa_pss_rsae_sha384',
    'rsa_pss_rsae_sha512',
    'ecdsa_secp256r1_sha256',
    'ecdsa_secp384r1_sha384',
    'ecdsa_secp521r1_sha512',
    'ed25519',
].join(':');
/**
 * Usually we would create separate timeouts for starting vs keep-alive.
 * Unfortunately quiche only has 1 config option that controls both.
 * And it is not possible to mutate this option after connecting.
 * Therefore, this option is just a way to set a shorter start timeout
 * compared to the idling timeout.
 * If this is the larger than the `maxIdleTimeout` (where `0` means `Infinity`),
 * then this has no effect. This only has an effect if this is set to a number
 * less than `maxIdleTimeout`. Thus, it is the "minimum boundary" of the
 * timeout when starting. While the `maxIdleTimeout` is still the "maximum
 * boundary" when starting.
 * Both `minIdleTimeout` and `maxIdleTimeout` defaults to `Infinity` (where `0`
 * means `Infinity` for `maxIdleTimeout`), thus by default connections will not
 * timeout when starting or during keep-alive.
 */
const minIdleTimeout = Infinity;
exports.minIdleTimeout = minIdleTimeout;
const clientDefault = {
    sigalgs,
    verifyPeer: true,
    grease: true,
    keepAliveIntervalTime: undefined,
    maxIdleTimeout: 0,
    maxRecvUdpPayloadSize: native_1.quiche.MAX_DATAGRAM_SIZE,
    maxSendUdpPayloadSize: native_1.quiche.MAX_DATAGRAM_SIZE,
    initialMaxData: 10 * 1024 * 1024,
    initialMaxStreamDataBidiLocal: 1 * 1024 * 1024,
    initialMaxStreamDataBidiRemote: 1 * 1024 * 1024,
    initialMaxStreamDataUni: 1 * 1024 * 1024,
    initialMaxStreamsBidi: 100,
    initialMaxStreamsUni: 100,
    maxConnectionWindow: native_1.quiche.MAX_CONNECTION_WINDOW,
    maxStreamWindow: native_1.quiche.MAX_STREAM_WINDOW,
    enableDgram: [false, 0, 0],
    disableActiveMigration: true,
    applicationProtos: ['quic'],
    enableEarlyData: true,
    readableChunkSize: 4 * 1024,
};
exports.clientDefault = clientDefault;
const serverDefault = {
    sigalgs,
    verifyPeer: false,
    grease: true,
    keepAliveIntervalTime: undefined,
    maxIdleTimeout: 0,
    maxRecvUdpPayloadSize: native_1.quiche.MAX_DATAGRAM_SIZE,
    maxSendUdpPayloadSize: native_1.quiche.MAX_DATAGRAM_SIZE,
    initialMaxData: 10 * 1024 * 1024,
    initialMaxStreamDataBidiLocal: 1 * 1024 * 1024,
    initialMaxStreamDataBidiRemote: 1 * 1024 * 1024,
    initialMaxStreamDataUni: 1 * 1024 * 1024,
    initialMaxStreamsBidi: 100,
    initialMaxStreamsUni: 100,
    maxConnectionWindow: native_1.quiche.MAX_CONNECTION_WINDOW,
    maxStreamWindow: native_1.quiche.MAX_STREAM_WINDOW,
    enableDgram: [false, 0, 0],
    disableActiveMigration: true,
    applicationProtos: ['quic'],
    enableEarlyData: true,
    readableChunkSize: 4 * 1024,
};
exports.serverDefault = serverDefault;
/**
 * Converts QUICConfig to QuicheConfig.
 * This does not use all the options of QUICConfig.
 * The QUICConfig is still necessary.
 */
function buildQuicheConfig(config) {
    if (config.key != null && config.cert == null) {
        throw new errors.ErrorQUICConfig('The cert option must be set when key is set');
    }
    else if (config.key == null && config.cert != null) {
        throw new errors.ErrorQUICConfig('The key option must be set when cert is set');
    }
    else if (config.key != null && config.cert != null) {
        if (Array.isArray(config.key) && Array.isArray(config.cert)) {
            if (config.key.length !== config.cert.length) {
                throw new errors.ErrorQUICConfig('The number of keys must match the number of certs');
            }
        }
    }
    // This is a concatenated CA certificates in PEM format
    let caPEMBuffer;
    if (config.ca != null) {
        const caPEMBuffers = utils.collectPEMs(config.ca);
        caPEMBuffer = utils.textEncoder.encode(caPEMBuffers.join(''));
    }
    // This is an array of private keys in PEM format as buffers
    let keyPEMBuffers;
    if (config.key != null) {
        const keyPEMs = utils.collectPEMs(config.key);
        keyPEMBuffers = keyPEMs.map((k) => utils.textEncoder.encode(k));
    }
    // This is an array of certificate chains in PEM format as buffers
    let certChainPEMBuffers;
    if (config.cert != null) {
        const certPEMsChain = utils.collectPEMs(config.cert);
        certChainPEMBuffers = certPEMsChain.map((c) => utils.textEncoder.encode(c));
    }
    let quicheConfig;
    try {
        quicheConfig = native_1.quiche.Config.withBoringSslCtx(config.verifyPeer, config.verifyCallback != null, caPEMBuffer, keyPEMBuffers, certChainPEMBuffers, config.sigalgs);
    }
    catch (e) {
        throw new errors.ErrorQUICConfig(`Failed to build Quiche config with custom SSL context: ${e.message}`, { cause: e });
    }
    if (config.logKeys != null) {
        quicheConfig.logKeys();
    }
    if (config.enableEarlyData) {
        quicheConfig.enableEarlyData();
    }
    quicheConfig.grease(config.grease);
    quicheConfig.setMaxIdleTimeout(config.maxIdleTimeout);
    quicheConfig.setMaxRecvUdpPayloadSize(config.maxRecvUdpPayloadSize);
    quicheConfig.setMaxSendUdpPayloadSize(config.maxSendUdpPayloadSize);
    quicheConfig.setInitialMaxData(config.initialMaxData);
    quicheConfig.setInitialMaxStreamDataBidiLocal(config.initialMaxStreamDataBidiLocal);
    quicheConfig.setInitialMaxStreamDataBidiRemote(config.initialMaxStreamDataBidiRemote);
    quicheConfig.setInitialMaxStreamDataUni(config.initialMaxStreamDataUni);
    quicheConfig.setInitialMaxStreamsBidi(config.initialMaxStreamsBidi);
    quicheConfig.setInitialMaxStreamsUni(config.initialMaxStreamsUni);
    quicheConfig.enableDgram(...config.enableDgram);
    quicheConfig.setDisableActiveMigration(config.disableActiveMigration);
    quicheConfig.setApplicationProtos(config.applicationProtos);
    return quicheConfig;
}
exports.buildQuicheConfig = buildQuicheConfig;
//# sourceMappingURL=config.js.map