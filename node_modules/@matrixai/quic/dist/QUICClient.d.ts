import type { PromiseCancellable } from '@matrixai/async-cancellable';
import type { ContextTimedInput } from '@matrixai/contexts';
import type { Host, Port, QUICClientCrypto, ResolveHostname, QUICClientConfigInput, StreamCodeToReason, StreamReasonToCode } from './types';
import type { Config } from './native/types';
import Logger from '@matrixai/logger';
import { EventAll } from '@matrixai/events';
import { CreateDestroy } from '@matrixai/async-init/dist/CreateDestroy';
import QUICSocket from './QUICSocket';
import QUICConnection from './QUICConnection';
import { ConnectionErrorCode } from './native';
import * as events from './events';
interface QUICClient extends CreateDestroy {
}
declare class QUICClient {
    /**
     * Creates a QUIC client.
     *
     * @param opts
     * @param opts.host - target host where wildcards are resolved to point locally.
     * @param opts.port - target port
     * @param opts.serverName - The expected name of the server you are connecting to, defaults to host.
     * @param opts.localHost - defaults to `::` (dual-stack)
     * @param opts.localPort - defaults 0
     * @param opts.socket - optional shared QUICSocket
     * @param opts.crypto - client needs to generate random bytes
     * @param opts.config - defaults to `clientDefault`
     * @param opts.resolveHostname - defaults to using OS DNS resolver
     * @param opts.reuseAddr - reuse existing port
     * @param opts.ipv6Only - force using IPv6 even when using `::`
     * @param opts.reasonToCode - maps stream error reasons to stream error codes
     * @param opts.codeToReason - maps stream error codes to reasons
     * @param opts.logger
     * @param ctx
     *
     * @throws {errors.ErrorQUICClientCreateTimeout} - if timed out
     * @throws {errors.ErrorQUICClientSocketNotRunning} - if shared socket is not running
     * @throws {errors.ErrorQUICClientInvalidHost} - if local host is incompatible with target host
     * @throws {errors.ErrorQUICSocket} - if socket start failed
     * @throws {errors.ErrorQUICConnection} - if connection start failed
     */
    static createQUICClient(opts: {
        host: string;
        port: number;
        serverName?: string;
        localHost?: string;
        localPort?: number;
        crypto: QUICClientCrypto;
        config?: QUICClientConfigInput;
        resolveHostname?: ResolveHostname;
        reuseAddr?: boolean;
        ipv6Only?: boolean;
        reasonToCode?: StreamReasonToCode;
        codeToReason?: StreamCodeToReason;
        logger?: Logger;
    }, ctx?: Partial<ContextTimedInput>): PromiseCancellable<QUICClient>;
    static createQUICClient(opts: {
        host: string;
        port: number;
        serverName?: string;
        socket: QUICSocket;
        crypto: QUICClientCrypto;
        config?: QUICClientConfigInput;
        reuseAddr?: boolean;
        ipv6Only?: boolean;
        reasonToCode?: StreamReasonToCode;
        codeToReason?: StreamCodeToReason;
        logger?: Logger;
    }, ctx?: Partial<ContextTimedInput>): PromiseCancellable<QUICClient>;
    readonly isSocketShared: boolean;
    readonly connection: QUICConnection;
    readonly closedP: Promise<void>;
    protected logger: Logger;
    protected socket: QUICSocket;
    protected config: Config;
    protected _closed: boolean;
    protected resolveClosedP: () => void;
    /**
     * Handles `EventQUICClientError`.
     *
     * This event propagates all errors from `QUICClient` and `QUICConnection`.
     * This means you can expect that `QUICConnection` errors will be logged
     * twice.
     *
     * Internal errors will be thrown upwards to become an uncaught exception.
     *
     * @throws {errors.ErrorQUICClientInternal}
     * @throws {errors.ErrorQUICConnectionInternal}
     */
    protected handleEventQUICClientError: (evt: events.EventQUICClientError) => void;
    /**
     * Handles `EventQUICClientClose`.
     * Registered once.
     *
     * This event propagates errors minus the internal errors.
     * All QUIC connections always close with an error, even if it is a graceful.
     *
     * If this event is dispatched first before `QUICClient.destroy`, it represents
     * an evented close. This could originate from the `QUICSocket` or
     * `QUICConnection`. If it was from the `QUICSocket`, then here it will stop
     * the `QUICConnection` with an transport code `InternalError`. If it was
     * from `QUICConnection`, then the `QUICConnection` will already be closing.
     * Therefore attempting to stop the `QUICConnection` will be idempotent.
     */
    protected handleEventQUICClientClose: (evt: events.EventQUICClientClose) => Promise<void>;
    /**
     * Handles all `EventQUICSocket` events.
     * Registered only if the socket is encapsulated.
     */
    protected handleEventQUICSocket: (evt: EventAll) => void;
    /**
     * Handles `EventQUICSocketStopped`.
     * Registered once.
     *
     * It is an error if the socket was stopped while `QUICClient` wasn't
     * destroyed.
     */
    protected handleEventQUICSocketStopped: () => void;
    /**
     * Handles all `EventQUICConnection` events.
     */
    protected handleEventQUICConnection: (evt: EventAll) => void;
    /**
     * Handles `EventQUICConnectionError`.
     *
     * All connection errors are redispatched as client errors.
     */
    protected handleEventQUICConnectionError: (evt: events.EventQUICConnectionError) => void;
    /**
     * Handles `EventQUICConnectionSend`.
     *
     * This will propagate the connection send buffers to the socket.
     * This may be concurrent and multiple send events may be processed
     * at a time.
     */
    protected handleEventQUICConnectionSend: (evt: events.EventQUICConnectionSend) => Promise<void>;
    /**
     * Handles `EventQUICConnectionStopped`.
     * Registered once.
     */
    protected handleEventQUICConnectionStopped: (evt: events.EventQUICConnectionStopped) => void;
    constructor({ socket, isSocketShared, connection, logger, }: {
        socket: QUICSocket;
        isSocketShared: boolean;
        connection: QUICConnection;
        logger: Logger;
    });
    get host(): Host;
    get port(): Port;
    get localHost(): Host;
    get localPort(): Port;
    get closed(): boolean;
    /**
     * Destroy the QUICClient.
     *
     * @param opts
     * @param opts.isApp - whether the destroy is initiated by the application
     * @param opts.errorCode - the error code to send to the peer
     * @param opts.reason - the reason to send to the peer
     * @param opts.force - force controls whether to cancel streams or wait for
     *                     streams to close gracefully
     */
    destroy({ isApp, errorCode, reason, force, }?: {
        isApp: false;
        errorCode?: ConnectionErrorCode;
        reason?: Uint8Array;
        force?: boolean;
    } | {
        isApp?: true;
        errorCode?: number;
        reason?: Uint8Array;
        force?: boolean;
    }): Promise<void>;
}
export default QUICClient;
