/// <reference types="node" />
/// <reference types="node" />
import type { Class, Callback, PromiseDeconstructed, Host, Port, QUICServerCrypto, ConnectionId, ConnectionIdString, StreamId } from './types';
import QUICConnectionId from './QUICConnectionId';
declare const textEncoder: TextEncoder;
declare const textDecoder: TextDecoder;
declare function never(message: string): never;
/**
 * Used to yield to the event loop to allow other micro tasks to process
 */
declare function yieldMicro(): Promise<void>;
/**
 * Convert callback-style to promise-style
 * If this is applied to overloaded function
 * it will only choose one of the function signatures to use
 */
declare function promisify<T extends Array<unknown>, P extends Array<unknown>, R extends T extends [] ? void : T extends [unknown] ? T[0] : T>(f: (...args: [...params: P, callback: Callback<T>]) => unknown): (...params: P) => Promise<R>;
/**
 * Deconstructed promise
 */
declare function promise<T = void>(): PromiseDeconstructed<T>;
/**
 * Zero-copy wraps ArrayBuffer-like objects into Buffer
 * This supports ArrayBuffer, TypedArrays and the NodeJS Buffer
 */
declare function bufferWrap(array: BufferSource, offset?: number, length?: number): Buffer;
/**
 * Is it an IPv4 address?
 */
declare function isIPv4(host: string): host is Host;
/**
 * Is it an IPv6 address?
 * This considers IPv4 mapped IPv6 addresses to also be IPv6 addresses.
 */
declare function isIPv6(host: string): host is Host;
/**
 * There are 2 kinds of IPv4 mapped IPv6 addresses.
 * 1. ::ffff:127.0.0.1 - dotted decimal version
 * 2. ::ffff:7f00:1 - hex version
 * Both are accepted by Node's dgram module.
 */
declare function isIPv4MappedIPv6(host: string): host is Host;
declare function isIPv4MappedIPv6Hex(host: string): host is Host;
declare function isIPv4MappedIPv6Dec(host: string): host is Host;
/**
 * Takes an IPv4 address and returns the IPv4 mapped IPv6 address.
 * This produces the dotted decimal variant.
 */
declare function toIPv4MappedIPv6Dec(host: string): Host;
/**
 * Takes an IPv4 address and returns the IPv4 mapped IPv6 address.
 * This produces the dotted Hexidecimal variant.
 */
declare function toIPv4MappedIPv6Hex(host: string): Host;
/**
 * Extracts the IPv4 portion out of the IPv4 mapped IPv6 address.
 * Can handle both the dotted decimal and hex variants.
 * 1. ::ffff:7f00:1
 * 2. ::ffff:127.0.0.1
 * Always returns the dotted decimal variant.
 */
declare function fromIPv4MappedIPv6(host: string): Host;
declare function isHostWildcard(host: Host): boolean;
/**
 * This converts all `IPv4` formats to the `IPv4` decimal format.
 * `IPv4` decimal and `IPv6` hex formatted IPs are left unchanged.
 */
declare function toCanonicalIP(host: string): Host;
/**
 * Zero IPs should be resolved to localhost when used as the target
 */
declare function resolvesZeroIP(host: Host): Host;
/**
 * This will resolve a hostname to the first host.
 * It could be an IPv6 address or IPv4 address.
 * This uses the OS's DNS resolution system.
 */
declare function resolveHostname(hostname: string): Promise<Host>;
/**
 * This will resolve a Host or Hostname to Host and `udp4` or `udp6`.
 * The `resolveHostname` can be overridden.
 */
declare function resolveHost(host: string, resolveHostname: (hostname: string) => string | PromiseLike<string>): Promise<[Host, 'udp4' | 'udp6']>;
/**
 * Is it a valid Port?
 */
declare function isPort(port: any): port is Port;
/**
 * Throws if port is invalid, otherwise returns port as Port.
 */
declare function toPort(port: any): Port;
/**
 * Given host and port, create an address string.
 */
declare function buildAddress(host: string, port?: number): string;
declare function validateTarget(socketHost: Host, socketType: 'ipv4' | 'ipv6' | 'ipv4&ipv6', targetHost: Host, targetUdpType: 'udp4' | 'udp6', errorClass: Class<Error>): Host;
/**
 * Collects PEM arrays specified in `QUICConfig` into a PEM chain array.
 * This can be used for keys, certs and ca.
 */
declare function collectPEMs(pems?: string | Array<string> | Uint8Array | Array<Uint8Array>): Array<string>;
/**
 * Converts PEM strings to DER Uint8Array
 */
declare function pemToDER(pem: string): Uint8Array;
/**
 * Converts DER Uint8Array to PEM string
 */
declare function derToPEM(der: Uint8Array): string;
/**
 * Formats error exceptions.
 * Example: `Error: description - message`
 */
declare function formatError(error: Error): string;
declare function encodeConnectionId(connId: ConnectionId): ConnectionIdString;
declare function decodeConnectionId(connIdString: ConnectionIdString): ConnectionId;
declare function mintToken(dcid: QUICConnectionId, peerHost: Host, crypto: QUICServerCrypto): Promise<Buffer>;
declare function validateToken(tokenBuffer: Buffer, peerHost: Host, crypto: QUICServerCrypto): Promise<QUICConnectionId | undefined>;
declare function isStreamClientInitiated(streamId: StreamId): boolean;
declare function isStreamServerInitiated(streamId: StreamId): boolean;
declare function isStreamUnidirectional(streamId: StreamId): boolean;
declare function isStreamBidirectional(streamId: StreamId): boolean;
/**
 * Note if the peer sends a corrupted `StreamStopped`, the `code` will be `NaN`
 * Furthermore it is limited to 16 digits the stringified maximum integer size of JS.
 */
declare function isStreamStopped(e: Error): number | false;
/**
 * Note if the peer sends a corrupted `StreamReset`, the `code` will be `NaN`
 * Furthermore it is limited to 16 digits the stringified maximum integer size of JS.
 */
declare function isStreamReset(e: Error): number | false;
/**
 * Increases the total number of registered event handlers before a node warning is emitted.
 * In most cases this is not needed but in the case where you have one event emitter for multiple handlers you'll need
 * to increase the limit.
 * @param target - The specific `EventTarget` or `EventEmitter` to increase the warning for.
 * @param limit - The limit before the warning is emitted, defaults to 100000.
 */
declare function setMaxListeners(target: EventTarget | NodeJS.EventEmitter, limit?: number): void;
export { textEncoder, textDecoder, never, yieldMicro, promisify, promise, bufferWrap, isIPv4, isIPv6, isIPv4MappedIPv6, isIPv4MappedIPv6Hex, isIPv4MappedIPv6Dec, toIPv4MappedIPv6Dec, toIPv4MappedIPv6Hex, fromIPv4MappedIPv6, isHostWildcard, toCanonicalIP, resolvesZeroIP, resolveHostname, resolveHost, isPort, toPort, buildAddress, validateTarget, collectPEMs, pemToDER, derToPEM, formatError, encodeConnectionId, decodeConnectionId, mintToken, validateToken, isStreamClientInitiated, isStreamServerInitiated, isStreamBidirectional, isStreamUnidirectional, isStreamStopped, isStreamReset, setMaxListeners, };
