"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dgram_1 = __importDefault(require("dgram"));
const logger_1 = __importDefault(require("@matrixai/logger"));
const StartStop_1 = require("@matrixai/async-init/dist/StartStop");
const errors_1 = require("@matrixai/errors");
const utils_1 = require("@matrixai/events/dist/utils");
const QUICConnectionId_1 = __importDefault(require("./QUICConnectionId"));
const QUICConnectionMap_1 = __importDefault(require("./QUICConnectionMap"));
const native_1 = require("./native");
const utils = __importStar(require("./utils"));
const events = __importStar(require("./events"));
const errors = __importStar(require("./errors"));
let QUICSocket = class QUICSocket {
    /**
     * The connection map is defined here so that it can be shared between
     * the `QUICClient` and the `QUICServer`. However every connection's
     * lifecycle is managed by either the `QUICClient` or `QUICServer`.
     * `QUICSocket` will not set or unset any connections in this connection map.
     * @internal
     */
    connectionMap = new QUICConnectionMap_1.default();
    logger;
    /**
     * Registered server for this socket.
     * If a server is not registered for this socket, all packets for new
     * connections will be dropped.
     */
    server;
    /**
     * Hostname resolver.
     */
    resolveHostname;
    _host;
    _port;
    _type;
    _closed = false;
    _closedP;
    resolveClosedP;
    socket;
    socketBind;
    socketClose;
    socketSend;
    handleEventQUICSocketError = (evt) => {
        const error = evt.detail;
        // Log out error for debugging
        this.logger.debug(utils.formatError(error));
    };
    handleEventQUICSocketClose = async () => {
        await this.socketClose();
        this._closed = true;
        this.resolveClosedP();
        if (this[StartStop_1.running]) {
            await this.stop({ force: true });
        }
    };
    /**
     * Handles UDP socket message.
     *
     * The `data` buffer could be multiple coalesced QUIC packets.
     * It could also be a non-QUIC packet data.
     * If it is non-QUIC, we can discard the data.
     * If there are multiple coalesced QUIC packets, it is expected that
     * all packets are intended for the same connection. This means we only
     * need to parse the first QUIC packet to determining what connection to route
     * the data to.
     */
    handleSocketMessage = async (data, remoteInfo) => {
        // The data buffer may have multiple coalesced QUIC packets.
        // This header is parsed from the first packet.
        let header;
        try {
            header = native_1.quiche.Header.fromSlice(data, native_1.quiche.MAX_CONN_ID_LEN);
        }
        catch (e) {
            // `BufferTooShort` and `InvalidPacket` means that this is not a QUIC
            // packet. If so, then we just ignore the packet.
            if (e.message === 'BufferTooShort' || e.message === 'InvalidPacket') {
                return;
            }
            // If the error is niether `BufferTooShort` or `InvalidPacket`, this
            // may indicate something went wrong in the header parsing, which should
            // be a software error.
            throw e;
        }
        // All QUIC packets will have the `dcid` header property
        // However short packets will not have the `scid` property
        // The destination connection ID is supposed to be our connection ID
        const dcid = new QUICConnectionId_1.default(header.dcid);
        const remoteInfo_ = {
            host: remoteInfo.address,
            port: remoteInfo.port,
        };
        const connection = this.connectionMap.get(dcid);
        if (connection != null) {
            // In the QUIC protocol, acknowledging packets while in a draining
            // state is optional. We can respond with `STATELESS_RESET`
            // but it's not necessary, and ignoring is simpler
            // https://www.rfc-editor.org/rfc/rfc9000.html#stateless-reset
            await connection.recv(data, remoteInfo_);
        }
        else {
            // If the server is not registered, we cannot attempt to create a new
            // connection for this packet.
            if (this.server == null) {
                return;
            }
            try {
                // This call will block until the connection is started which
                // may require multiple `recv` and `send` pairs to process the
                // received packets.
                // In order to do this, firstly the initial `data` is faciliated by the
                // `QUICServer`. And subsequently multiple `recv` and `send` pairs will
                // occur concurrently while the the connection is starting.
                // These concurrent `recv` and `send` pairs occur in this same handler,
                // but just in the other branch of the current `if` statement where
                // the connection object already exists in the connection map.
                await this.server.acceptConnection(remoteInfo_, header, dcid, data);
            }
            catch (e) {
                if (errors_1.utils.checkError(e, (e) => e instanceof errors.ErrorQUICSocket)) {
                    const e_ = new errors.ErrorQUICSocketInternal('Failed to call accept connection due to socket send', { cause: e });
                    this.dispatchEvent(new events.EventQUICSocketError({
                        detail: e_,
                    }));
                    this.dispatchEvent(new events.EventQUICSocketClose());
                    return;
                }
                // If the connection timed out during start, this is an expected
                // possibility, because the remote peer might have become unavailable,
                // in which case we can just ignore the error here.
                if (e instanceof errors.ErrorQUICServerNewConnection) {
                    return;
                }
                throw e;
            }
        }
    };
    /**
     * Constructs a QUIC socket.
     *
     * @param opts
     * @param opts.resolveHostname - defaults to using OS DNS resolver
     * @param opts.logger
     */
    constructor({ resolveHostname = utils.resolveHostname, logger, }) {
        this.logger = logger ?? new logger_1.default(this.constructor.name);
        this.resolveHostname = resolveHostname;
        const { p: closedP, resolveP: resolveClosedP } = utils.promise();
        this._closedP = closedP;
        this.resolveClosedP = resolveClosedP;
    }
    /**
     * Gets the bound resolved host IP (not hostname).
     * This can be the IPv4 or IPv6 address.
     * This could be a wildcard address which means all interfaces.
     * Note that `::` can mean all IPv4 and all IPv6.
     * Whereas `0.0.0.0` means only all IPv4.
     */
    get host() {
        return this._host;
    }
    /**
     * Gets the bound resolved port.
     * This cannot be `0`.
     * Because `0` is always resolved to a specific port.
     */
    get port() {
        return this._port;
    }
    /**
     * Gets the type of socket
     * It can be ipv4-only, ipv6-only or dual stack
     */
    get type() {
        return this._type;
    }
    get closed() {
        return this._closed;
    }
    get closedP() {
        return this._closedP;
    }
    /**
     * Starts this QUICSocket.
     * This supports hostnames and IPv4 and IPv6 addresses.
     * If the host is `::`, this will also bind to `0.0.0.0`.
     *
     * @param opts
     * @param opts.host - The host to bind to. Default is `::`.
     * @param opts.port - The port to bind to. Default is `0`.
     * @param opts.reuseAddr - Whether to reuse the address. Default is `false`.
     * @param opts.ipv6Only - Whether to only bind to IPv6. Default is `false`.
     *
     * @throws {errors.ErrorQUICSocketInvalidBindAddress} If bind failed due to
     * EINVAL or ENOTFOUND. EINVAL is due to using IPv4 host when creating a
     * `udp6` socket. ENOTFOUND is when the hostname does not resolve
     * or does not resolve to IPv6 when creating a `udp6` socket or does not
     * resolve to IPv4 when creating a `udp4` socket.
     */
    async start({ host = '::', port = 0, reuseAddr = false, ipv6Only = false, } = {}) {
        // Since we have a one-to-many relationship with clients and connections,
        // we want to up the warning limit on the EventTarget
        utils.setMaxListeners(this[utils_1._eventTarget]);
        let address = utils.buildAddress(host, port);
        this.logger.info(`Start ${this.constructor.name} on ${address}`);
        // Resolves the host which could be a hostname and acquire the type.
        // If the host is an IPv4 mapped IPv6 address, then the type should be udp6.
        const [host_, udpType] = await utils.resolveHost(host, this.resolveHostname);
        const port_ = utils.toPort(port);
        this.socket = dgram_1.default.createSocket({
            type: udpType,
            reuseAddr,
            ipv6Only,
        });
        this.socketBind = utils.promisify(this.socket.bind).bind(this.socket);
        this.socketClose = utils.promisify(this.socket.close).bind(this.socket);
        this.socketSend = utils.promisify(this.socket.send).bind(this.socket);
        const { p: errorP, rejectP: rejectErrorP } = utils.promise();
        // Prevent promise rejection leak
        void errorP.catch(() => { });
        this.socket.once('error', rejectErrorP);
        // This resolves DNS via `getaddrinfo` under the hood.
        // It which respects the hosts file.
        // This makes it equivalent to `dns.lookup`.
        const socketBindP = this.socketBind(port_, host_);
        try {
            await Promise.race([socketBindP, errorP]);
        }
        catch (e) {
            // Possible binding failure due to EINVAL or ENOTFOUND.
            // EINVAL due to using IPv4 address where udp6 is specified.
            // ENOTFOUND when the hostname doesn't resolve, or doesn't resolve to IPv6 if udp6 is specified
            // or doesn't resolve to IPv4 if udp4 is specified.
            throw new errors.ErrorQUICSocketInvalidBindAddress(host !== host_
                ? `Could not bind to resolved ${host} -> ${host_}`
                : `Could not bind to ${host}`, {
                cause: e,
            });
        }
        this.socket.removeListener('error', rejectErrorP);
        // The dgram socket's error events might just be informational
        // They don't necessarily correspond to an error
        // Therefore we don't bother listening for it
        // Unless we were propagating default events upwards
        const socketAddress = this.socket.address();
        // This is the resolved IP, not the original hostname
        this._host = socketAddress.address;
        this._port = socketAddress.port;
        // Dual stack only exists for `::` and `!ipv6Only`
        if (host_ === '::' && !ipv6Only) {
            this._type = 'ipv4&ipv6';
        }
        else if (udpType === 'udp4' || utils.isIPv4MappedIPv6(host_)) {
            this._type = 'ipv4';
        }
        else if (udpType === 'udp6') {
            this._type = 'ipv6';
        }
        this.socket.on('message', this.handleSocketMessage);
        this.addEventListener(events.EventQUICSocketError.name, this.handleEventQUICSocketError);
        this.addEventListener(events.EventQUICSocketClose.name, this.handleEventQUICSocketClose, { once: true });
        this._closed = false;
        address = utils.buildAddress(this._host, this._port);
        this.logger.info(`Started ${this.constructor.name} on ${address}`);
    }
    /**
     * Stop this QUICSocket.
     *
     * @param opts
     * @param opts.force - Stop the socket even if the connection map is not empty.
     *
     * @throws {errors.ErrorQUICSocketConnectionsActive}
     */
    async stop({ force = false, } = {}) {
        const address = utils.buildAddress(this._host, this._port);
        this.logger.info(`Stop ${this.constructor.name} on ${address}`);
        if (!force && this.connectionMap.size > 0) {
            throw new errors.ErrorQUICSocketConnectionsActive(`Cannot stop QUICSocket with ${this.connectionMap.size} active connection(s)`);
        }
        if (!this._closed) {
            this.dispatchEvent(new events.EventQUICSocketClose());
        }
        await this._closedP;
        // Resets the `closedP`
        const { p: closedP, resolveP: resolveClosedP } = utils.promise();
        this._closedP = closedP;
        this.resolveClosedP = resolveClosedP;
        this.removeEventListener(events.EventQUICSocketError.name, this.handleEventQUICSocketError);
        this.removeEventListener(events.EventQUICSocketClose.name, this.handleEventQUICSocketClose);
        this.socket.off('message', this.handleSocketMessage);
        this.logger.info(`Stopped ${this.constructor.name} on ${address}`);
    }
    async send(...params) {
        let index;
        if (params.length === 3 && typeof params[2] === 'string') {
            index = 2;
        }
        else if (params.length === 5 && typeof params[4] === 'string') {
            index = 4;
        }
        else {
            throw new TypeError('QUICSocket.send requires `port` and `address` parameters');
        }
        const host = params[index];
        let [host_, udpType] = await utils.resolveHost(host, this.resolveHostname);
        host_ = utils.resolvesZeroIP(host_);
        host_ = utils.validateTarget(this._host, this._type, host_, udpType, errors.ErrorQUICSocketInvalidSendAddress);
        params[index] = host_;
        return this.socketSend(...params);
    }
    async send_(...params) {
        return this.socketSend(...params);
    }
    setServer(server) {
        this.server = server;
    }
    unsetServer() {
        delete this.server;
    }
};
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICSocketNotRunning())
], QUICSocket.prototype, "host", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICSocketNotRunning())
], QUICSocket.prototype, "port", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICSocketNotRunning())
], QUICSocket.prototype, "type", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICSocketNotRunning())
], QUICSocket.prototype, "send", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICSocketNotRunning())
], QUICSocket.prototype, "send_", null);
QUICSocket = __decorate([
    (0, StartStop_1.StartStop)({
        eventStart: events.EventQUICSocketStart,
        eventStarted: events.EventQUICSocketStarted,
        eventStop: events.EventQUICSocketStop,
        eventStopped: events.EventQUICSocketStopped,
    })
], QUICSocket);
exports.default = QUICSocket;
//# sourceMappingURL=QUICSocket.js.map