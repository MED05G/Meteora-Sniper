"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@matrixai/logger"));
const timer_1 = require("@matrixai/timer");
const async_locks_1 = require("@matrixai/async-locks");
const events_1 = require("@matrixai/events");
const StartStop_1 = require("@matrixai/async-init/dist/StartStop");
const decorators_1 = require("@matrixai/contexts/dist/decorators");
const config_1 = require("./config");
const QUICConnectionId_1 = __importDefault(require("./QUICConnectionId"));
const QUICStream_1 = __importDefault(require("./QUICStream"));
const native_1 = require("./native");
const types_1 = require("./native/types");
const utils = __importStar(require("./utils"));
const events = __importStar(require("./events"));
const errors = __importStar(require("./errors"));
let QUICConnection = class QUICConnection {
    /**
     * This determines when it is a client or server connection.
     */
    type;
    /**
     * Resolves once the connection has closed.
     */
    closedP;
    /**
     * Internal native connection object.
     * @internal
     */
    conn;
    /**
     * Internal stream map.
     * @internal
     */
    streamMap = new Map();
    /**
     * Unique id used to identify events intended for this connection.
     */
    sendId;
    logger;
    socket;
    config;
    reasonToCode;
    codeToReason;
    /**
     * This ensures that `recv` is serialised.
     * Prevents a new `recv` call intercepting the previous `recv` call that is
     * still finishing up with a `send` call.
     */
    recvLock = new async_locks_1.Lock();
    /**
     * Client initiated bidirectional stream starts at 0.
     * Increment by 4 to get the next ID.
     */
    streamIdClientBidi = 0b00;
    /**
     * Server initiated bidirectional stream starts at 1.
     * Increment by 4 to get the next ID.
     */
    streamIdServerBidi = 0b01;
    /**
     * Client initiated unidirectional stream starts at 2.
     * Increment by 4 to get the next ID.
     */
    streamIdClientUni = 0b10;
    /**
     * Server initiated unidirectional stream starts at 3.
     * Increment by 4 to get the next ID.
     */
    streamIdServerUni = 0b11;
    /**
     * Tracks the highest StreamId that has a created QUICStream for clientBidi
     */
    streamIdUsedClientBidi = (0b00 - 4);
    /**
     * Tracks the highest StreamId that has a created QUICStream for serverBidi
     */
    streamIdUsedServerBidi = (0b01 - 4);
    /**
     * Tracks the highest StreamId that has a created QUICStream for clientUni
     */
    streamIdUsedClientUni = (0b10 - 4);
    /**
     * Tracks the highest StreamId that has a created QUICStream for clientUni
     */
    streamIdUsedServerUni = (0b11 - 4);
    /**
     * Tracks used ids that have skipped the expected next id for the streamIdUsed counters.
     * If the next id in the streamIdUsed sequence is used then we remove IDs from the Set
     * up to the next ID gap.
     */
    streamIdUsedSet = new Set();
    /**
     * Quiche connection timer. This performs time delayed state transitions.
     */
    connTimeoutTimer;
    /**
     * Keep alive timer.
     *
     * Quiche does not natively ensure activity on the connection. This interval
     * timer guarantees that there will be activity on the connection by sending
     * acknowlegement eliciting frames, which will cause the peer to acknowledge.
     *
     * This is still useful even if the `config.maxIdleTimeout` is set to 0, which
     * means the connection will never timeout due to being idle.
     *
     * This mechanism will only start working after `secureEstablishedP`.
     */
    keepAliveIntervalTimer;
    /**
     * Remote host which can change on every `QUICConnection.recv`.
     */
    _remoteHost;
    /**
     * Remote port which can change on every `QUICConnection.recv`.
     */
    _remotePort;
    /**
     * Chain of local certificates from leaf to root in DER format.
     */
    certDERs = [];
    /**
     * Array of independent CA certificates in DER format.
     */
    caDERs = [];
    /**
     * Secure connection establishment means that this connection has completed
     * peer certificate verification, and the connection is ready to be used.
     */
    secureEstablished = false;
    /**
     * Resolves after connection is established and peer certs have been verified.
     */
    secureEstablishedP;
    resolveSecureEstablishedP;
    rejectSecureEstablishedP;
    resolveClosedP;
    /**
     * Stores the last dispatched error. If no error, it will be `null`.
     *
     * `QUICConnection.stop` will need this if it is called by the user concurrent
     * with handling `EventQUICConnectionError`. It ensures that `this.stop` uses
     * the original error when force destroying the streams.
     */
    errorLast = null;
    /**
     * Handle `EventQUICConnectionError`.
     *
     * QUIC connections always close with errors. Graceful errors are logged out
     * at INFO level, while non-graceful errors are logged out at ERROR level.
     *
     * Internal errors will be thrown upwards to become an uncaught exception.
     *
     * @throws {errors.ErrorQUICConnectionInternal}
     */
    handleEventQUICConnectionError = (evt) => {
        const error = evt.detail;
        this.errorLast = error;
        // Log out error for debugging
        this.logger.info(utils.formatError(error));
        if (error instanceof errors.ErrorQUICConnectionInternal) {
            throw error;
        }
        this.dispatchEvent(new events.EventQUICConnectionClose({
            detail: error,
        }));
    };
    /**
     * Handles `EventQUICConnectionClose`.
     * Registered once.
     *
     * This event means that `this.conn.close()` is already called.
     * It does not mean that `this.closedP` is resolved. The resolving of
     * `this.closedP` depends on the `this.connTimeoutTimer`.
     */
    handleEventQUICConnectionClose = async (evt) => {
        const error = evt.detail;
        // Reject the secure established promise
        // This will allow `this.start()` to reject with the error.
        // No effect if this connection is running.
        if (!this.secureEstablished) {
            this.rejectSecureEstablishedP(error);
        }
        // Complete the final send call if it was a local close
        if (error instanceof errors.ErrorQUICConnectionLocal) {
            await this.send();
        }
        // If the connection is still running, we will force close the connection
        if (this[StartStop_1.running] && this[StartStop_1.status] !== 'stopping') {
            // The `stop` will need to retrieve the error from `this.errorLast`
            await this.stop({
                force: true,
            });
        }
    };
    /**
     * Handles all `EventQUICStream` events.
     */
    handleEventQUICStream = (evt) => {
        if (evt.detail instanceof events_1.AbstractEvent &&
            // Avoid cloning the `EventQUICStreamSend` event as it's very low level
            !(evt.detail instanceof events.EventQUICStreamSend)) {
            this.dispatchEvent(evt.detail.clone());
        }
    };
    /**
     * Handles `EventQUICStreamSend`.
     *
     * This handler will trigger `this.send` when there is data in the writable
     * stream buffer. As this is asynchronous, it is necessary to check if this
     * `QUICConnection` is still running.
     */
    handleEventQUICStreamSend = async () => {
        if (this[StartStop_1.running])
            await this.send();
    };
    /**
     * Handles `EventQUICStreamDestroyed`.
     * Registered once.
     */
    handleEventQUICStreamDestroyed = (evt) => {
        const quicStream = evt.target;
        quicStream.removeEventListener(events.EventQUICStreamSend.name, this.handleEventQUICStreamSend);
        quicStream.removeEventListener(events_1.EventAll.name, this.handleEventQUICStream);
        this.streamMap.delete(quicStream.streamId);
    };
    /**
     * Constructs a QUIC connection.
     *
     * @param opts
     * @param opts.type - client or server connection
     * @param opts.scid - source connection ID
     * @param opts.dcid - destination connection ID
     * @param opts.serverName - client connections can use server name for
     *                          verifying the server's certificate, however if
     *                          `config.verifyCallback` is set, this will have no
     *                          effect
     * @param opts.remoteInfo - remote host and port
     * @param opts.config - QUIC config
     * @param opts.socket - injected socket
     * @param opts.reasonToCode - maps stream error reasons to stream error codes
     * @param opts.codeToReason - maps stream error codes to reasons
     * @param opts.logger
     *
     * @throws {errors.ErrorQUICConnectionConfigInvalid}
     */
    constructor({ type, scid, dcid, serverName = null, remoteInfo, config, socket, reasonToCode = () => 0, codeToReason = (type, code) => new Error(`${type} ${code}`), logger, }) {
        this.logger = logger ?? new logger_1.default(`${this.constructor.name} ${scid}`);
        this.sendId = scid.toString();
        if (config.keepAliveIntervalTime != null &&
            config.maxIdleTimeout !== 0 &&
            config.keepAliveIntervalTime >= config.maxIdleTimeout) {
            throw new errors.ErrorQUICConnectionConfigInvalid('`keepAliveIntervalTime` must be less than `maxIdleTimeout`');
        }
        const quicheConfig = (0, config_1.buildQuicheConfig)(config);
        let conn;
        if (type === 'client') {
            this.logger.info(`Connect ${this.constructor.name}`);
            conn = native_1.quiche.Connection.connect(serverName, scid, {
                host: socket.host,
                port: socket.port,
            }, {
                host: remoteInfo.host,
                port: remoteInfo.port,
            }, quicheConfig);
        }
        else if (type === 'server') {
            this.logger.info(`Accept ${this.constructor.name}`);
            conn = native_1.quiche.Connection.accept(scid, dcid, {
                host: socket.host,
                port: socket.port,
            }, {
                host: remoteInfo.host,
                port: remoteInfo.port,
            }, quicheConfig);
        }
        // This will output to the log keys file path
        if (config.logKeys != null) {
            conn.setKeylog(config.logKeys);
        }
        this.type = type;
        this.conn = conn;
        this.socket = socket;
        this.config = config;
        if (this.config.cert != null) {
            const certPEMs = utils.collectPEMs(this.config.cert);
            this.certDERs = certPEMs.map(utils.pemToDER);
        }
        if (this.config.ca != null) {
            const caPEMs = utils.collectPEMs(this.config.ca);
            this.caDERs = caPEMs.map(utils.pemToDER);
        }
        this.reasonToCode = reasonToCode;
        this.codeToReason = codeToReason;
        this._remoteHost = remoteInfo.host;
        this._remotePort = remoteInfo.port;
        const { p: secureEstablishedP, resolveP: resolveSecureEstablishedP, rejectP: rejectSecureEstablishedP, } = utils.promise();
        // Prevent promise rejection leak
        secureEstablishedP.catch(() => { });
        this.secureEstablishedP = secureEstablishedP;
        this.resolveSecureEstablishedP = () => {
            // This is an idempotent mutation
            this.secureEstablished = true;
            resolveSecureEstablishedP();
        };
        this.rejectSecureEstablishedP = rejectSecureEstablishedP;
        const { p: closedP, resolveP: resolveClosedP } = utils.promise();
        this.closedP = closedP;
        this.resolveClosedP = resolveClosedP;
    }
    /**
     * This is the source connection ID.
     */
    get connectionId() {
        const sourceId = this.conn.sourceId();
        // Zero copy construction of QUICConnectionId
        return new QUICConnectionId_1.default(sourceId.buffer, sourceId.byteOffset, sourceId.byteLength);
    }
    /**
     * This is the destination connection ID.
     * This is only fully known after establishing the connection
     */
    get connectionIdPeer() {
        const destinationId = this.conn.destinationId();
        // Zero copy construction of QUICConnectionId
        return new QUICConnectionId_1.default(destinationId.buffer, destinationId.byteOffset, destinationId.byteLength);
    }
    /**
     * A common ID between the client and server connection.
     * Used to identify connection pairs more easily.
     */
    get connectionIdShared() {
        const sourceId = this.conn.sourceId();
        const destinationId = this.conn.destinationId();
        if (Buffer.compare(sourceId, destinationId) <= 0) {
            return new QUICConnectionId_1.default(Buffer.concat([sourceId, destinationId]));
        }
        else {
            return new QUICConnectionId_1.default(Buffer.concat([destinationId, sourceId]));
        }
    }
    get remoteHost() {
        return this._remoteHost;
    }
    get remotePort() {
        return this._remotePort;
    }
    get localHost() {
        return this.socket.host;
    }
    get localPort() {
        return this.socket.port;
    }
    get closed() {
        return this.conn.isClosed();
    }
    async start({ data, remoteInfo, } = {}, ctx) {
        this.logger.info(`Start ${this.constructor.name}`);
        // If the connection has already been closed, we cannot start it again
        if (this.conn.isClosed()) {
            throw new errors.ErrorQUICConnectionClosed();
        }
        ctx.signal.throwIfAborted();
        const { p: abortP, rejectP: rejectAbortP } = utils.promise();
        // Prevent promise rejection leak
        void abortP.catch(() => { });
        const abortHandler = () => {
            rejectAbortP(ctx.signal.reason);
        };
        ctx.signal.addEventListener('abort', abortHandler);
        this.addEventListener(events.EventQUICConnectionError.name, this.handleEventQUICConnectionError);
        this.addEventListener(events.EventQUICConnectionClose.name, this.handleEventQUICConnectionClose, { once: true });
        if (this.type === 'client') {
            await this.send();
        }
        else if (this.type === 'server') {
            if (data == null || remoteInfo == null) {
                throw new errors.ErrorQUICConnectionStartData('Starting a server connection requires initial data and remote information');
            }
            await this.recv(data, remoteInfo);
        }
        try {
            // This will block until the connection is established
            await Promise.race([this.secureEstablishedP, abortP]);
        }
        catch (e) {
            if (ctx.signal.aborted) {
                // No `QUICStream` objects could have been created, however quiche stream
                // state should be cleaned up, and this can be done synchronously
                for (const streamId of this.conn.readable()) {
                    this.conn.streamShutdown(streamId, native_1.quiche.Shutdown.Read, this.reasonToCode('read', e));
                }
                for (const streamId of this.conn.writable()) {
                    this.conn.streamShutdown(streamId, native_1.quiche.Shutdown.Write, this.reasonToCode('write', e));
                }
                // According to RFC9000, closing while in the middle of a handshake
                // should use a transport error code `APPLICATION_ERROR`.
                // For this library we extend this "handshake" phase to include the
                // the TLS handshake too.
                // This is also the behaviour of quiche when the connection is not
                // in a "safe" state to send application errors (where `app` parameter is true).
                // https://www.rfc-editor.org/rfc/rfc9000.html#section-10.2.3-3
                this.conn.close(false, native_1.ConnectionErrorCode.ApplicationError, Buffer.from(''));
                const localError = this.conn.localError();
                const e_ = new errors.ErrorQUICConnectionLocal('Failed to start QUIC connection due to start timeout', {
                    data: localError,
                    cause: e,
                });
                this.dispatchEvent(new events.EventQUICConnectionError({
                    detail: e_,
                }));
            }
            // Wait for the connection to be fully closed by the `this.connTimeoutTimer`
            await this.closedP;
            // Throws original exception
            throw e;
        }
        finally {
            ctx.signal.removeEventListener('abort', abortHandler);
        }
        if (this.config.keepAliveIntervalTime != null) {
            this.startKeepAliveIntervalTimer(this.config.keepAliveIntervalTime);
        }
        this.logger.info(`Started ${this.constructor.name}`);
    }
    /**
     * Stops the QUIC connection.
     *
     * @param opts
     * @param opts.isApp - whether the destroy is initiated by the application
     * @param opts.errorCode - the error code to send to the peer, use
     *                         `ConnectionErrorCode` if `isApp` is false,
     *                         otherwise any unsigned integer is fine.
     * @param opts.reason - the reason to send to the peer
     * @param opts.force - force controls whether to cancel streams or wait for
     *                     streams to close gracefully
     *
     * The provided error parameters is only used if the quiche connection is not
     * draining or closed.
     */
    async stop({ isApp = true, errorCode = 0, reason = new Uint8Array(), force = true, } = {}) {
        this.logger.info(`Stop ${this.constructor.name}`);
        this.stopKeepAliveIntervalTimer();
        // Yield to allow any background processing to settle before proceeding.
        // This will allow any streams to process buffers before continuing
        await utils.yieldMicro();
        // Destroy all streams
        const streamsDestroyP = [];
        for (const quicStream of this.streamMap.values()) {
            // The reason is only used if `force` is `true`
            // If `force` is not true, this will gracefully wait for
            // both readable and writable to gracefully close
            streamsDestroyP.push(quicStream.destroy({
                reason: this.errorLast,
                force: force || this.conn.isDraining() || this.conn.isClosed(),
            }));
        }
        await Promise.all(streamsDestroyP);
        // Close after processing all streams
        if (!this.conn.isDraining() && !this.conn.isClosed()) {
            // If `this.conn.close` is already called, the connection will be draining,
            // in that case we just skip doing this local close.
            // If `this.conn.isTimedOut` is true, then the connection will be closed,
            // in that case we skip doing this local close.
            this.conn.close(isApp, errorCode, reason);
            const localError = this.conn.localError();
            const message = `Locally closed with ${localError.isApp ? 'application' : 'transport'} code ${localError.errorCode}`;
            const e = new errors.ErrorQUICConnectionLocal(message, {
                data: localError,
            });
            this.dispatchEvent(new events.EventQUICConnectionError({ detail: e }));
        }
        // Waiting for `closedP` to resolve
        // Only the `this.connTimeoutTimer` will resolve this promise
        await this.closedP;
        this.removeEventListener(events.EventQUICConnectionError.name, this.handleEventQUICConnectionError);
        this.removeEventListener(events.EventQUICConnectionClose.name, this.handleEventQUICConnectionClose);
        this.logger.info(`Stopped ${this.constructor.name}`);
    }
    /**
     * Get connection error.
     * This could be `undefined` if connection timed out.
     */
    getConnectionError() {
        return this.conn.localError() ?? this.conn.peerError() ?? undefined;
    }
    /**
     * Array of independent CA certificates in DER format.
     */
    getLocalCACertsChain() {
        return this.caDERs;
    }
    /**
     * Chain of local certificates from leaf to root in DER format.
     */
    getLocalCertsChain() {
        return this.certDERs;
    }
    /**
     * Chain of remote certificates from leaf to root in DER format.
     */
    getRemoteCertsChain() {
        return this.conn.peerCertChain() ?? [];
    }
    meta() {
        return {
            localHost: this.localHost,
            localPort: this.localPort,
            remoteHost: this.remoteHost,
            remotePort: this.remotePort,
            localCertsChain: this.certDERs,
            localCACertsChain: this.caDERs,
            remoteCertsChain: this.getRemoteCertsChain(),
        };
    }
    /**
     * Receives data from the socket for this connection.
     *
     * The data flows from the socket this connection to streams.
     * This takes data from the quiche connection and pushes to the
     * `QUICStream` collection.
     *
     * This function is callable during `this.start` and `this.stop`.
     * When the connection is draining, we can still receive data.
     * However no streams are allowed to read or write data.
     *
     * @internal
     */
    async recv(data, remoteInfo) {
        // Enforce mutual exclusion for an atomic pair of `this.recv` and `this.send`.
        await this.recvLock.withF(async () => {
            const recvInfo = {
                to: {
                    host: this.localHost,
                    port: this.localPort,
                },
                from: {
                    host: remoteInfo.host,
                    port: remoteInfo.port,
                },
            };
            try {
                // This can process multiple QUIC packets.
                // Remember that 1 QUIC packet can have multiple QUIC frames.
                // Expect the `data` is mutated here due to in-place decryption,
                // so do not re-use the `data` afterwards.
                this.conn.recv(data, recvInfo);
            }
            catch (e) {
                // If `config.verifyPeer` is true and `config.verifyCallback` is undefined,
                // then during the TLS handshake, a `TlsFail` exception will only be thrown
                // if the peer did not supply a certificate or that its certificate failed
                // the default certificate verification procedure.
                // If `config.verifyPeer` is true and `config.verifyCallback` is defined,
                // then during the TLS handshake, a `TlsFail` exception will only be thrown
                // if the peer did not supply a peer certificate.
                const localError = this.conn.localError();
                if (localError == null) {
                    // If there was no local error, then this is an internal error.
                    const e_ = new errors.ErrorQUICConnectionInternal('Failed connection recv due with unknown error', { cause: e });
                    this.dispatchEvent(new events.EventQUICConnectionError({ detail: e_ }));
                    throw e_;
                }
                else {
                    // Quiche connection recv will automatically close with local
                    // connection error and start draining.
                    // This is a legitimate state transition.
                    let e_;
                    if (e.message === 'TlsFail') {
                        e_ = new errors.ErrorQUICConnectionLocalTLS('Failed connection due to native TLS verification', {
                            cause: e,
                            data: localError,
                        });
                    }
                    else {
                        e_ = new errors.ErrorQUICConnectionLocal('Failed connection due to local error', {
                            cause: e,
                            data: localError,
                        });
                    }
                    this.dispatchEvent(new events.EventQUICConnectionError({ detail: e_ }));
                    return;
                }
            }
            // The remote information may be changed on each received packet.
            // If it changes, this would mean the connection has migrated.
            this._remoteHost = remoteInfo.host;
            this._remotePort = remoteInfo.port;
            // If `config.verifyCallback` is not defined, simply being established is
            // sufficient to mean we are securely established, however if it is defined
            // then secure establishment occurs only after custom TLS verification has
            // passed.
            if (!this.secureEstablished &&
                this.conn.isEstablished() &&
                this.config.verifyCallback == null) {
                this.resolveSecureEstablishedP();
            }
            // If we are securely established we can process streams.
            if (this.secureEstablished) {
                this.processStreams();
            }
            // After every recv, there must be a send.
            await this.send();
        });
    }
    /**
     * Sends data to the socket from this connection.
     *
     * This takes the data from the quiche connection that is on the send buffer.
     * The data flows from the streams to this connection to the socket.
     *
     * - Call this if connecting to a server.
     * - Call this if `recv` is called.
     * - Call this if `connTimeoutTimer` ticks.
     * - Call this if stream is written.
     * - Call this if stream is read.
     *
     * This function is callable during `this.start` and `this.stop`.
     * When the connection is draining, we can still receive data.
     * However no streams are allowed to read or write data.
     *
     * @internal
     */
    async send() {
        let sendLength;
        let sendInfo;
        // Send until `Done`
        while (true) {
            // Fastest way of allocating a buffer, which will be dispatched
            const sendBuffer = Buffer.allocUnsafe(this.config.maxSendUdpPayloadSize);
            try {
                const result = this.conn.send(sendBuffer);
                if (result === null) {
                    // Break the loop
                    break;
                }
                [sendLength, sendInfo] = result;
            }
            catch (e) {
                // Internal error if send failed
                const e_ = new errors.ErrorQUICConnectionInternal('Failed connection send with unknown internal error', { cause: e });
                this.dispatchEvent(new events.EventQUICConnectionError({ detail: e_ }));
                throw e_;
            }
            this.dispatchEvent(new events.EventQUICConnectionSend({
                detail: {
                    id: this.sendId,
                    msg: sendBuffer.subarray(0, sendLength),
                    port: sendInfo.to.port,
                    address: sendInfo.to.host,
                },
            }));
        }
        // Resets the `this.connTimeoutTimer` because quiche timeout becomes
        // non-null after the first send call is made, and subsequently, each
        // send call may end up resetting the quiche timeout value.
        this.setConnTimeoutTimer();
        if (!this.secureEstablished &&
            !this.conn.isDraining() &&
            !this.conn.isClosed() &&
            this.conn.isEstablished() &&
            this.config.verifyPeer &&
            this.config.verifyCallback != null) {
            const peerCertsChain = this.conn.peerCertChain();
            // Custom TLS verification
            const cryptoError = await this.config.verifyCallback(peerCertsChain, this.caDERs);
            if (cryptoError != null) {
                // This simulates the crypto error that occurs natively
                this.conn.close(false, cryptoError, Buffer.from(''));
                const localError = this.conn.localError();
                const e_ = new errors.ErrorQUICConnectionLocalTLS('Failed connection due to custom TLS verification', {
                    data: localError,
                });
                this.dispatchEvent(new events.EventQUICConnectionError({
                    detail: e_,
                }));
                return;
            }
            // If this succeeds, then we have securely established, and we can
            // process all the streams, that would have originally occurred in
            // `this.recv`. This will only be run on the first time, we perform
            // the custom TLS verification
            this.resolveSecureEstablishedP();
            this.processStreams();
        }
        if (this[StartStop_1.status] !== 'stopping') {
            const peerError = this.conn.peerError();
            if (peerError != null) {
                const message = `Peer closed with ${peerError.isApp ? 'application' : 'transport'} code ${peerError.errorCode}`;
                if (peerError.errorCode >= native_1.quiche.CRYPTO_ERROR_START &&
                    peerError.errorCode <= native_1.quiche.CRYPTO_ERROR_STOP) {
                    this.dispatchEvent(new events.EventQUICConnectionError({
                        detail: new errors.ErrorQUICConnectionPeerTLS(message, {
                            data: peerError,
                        }),
                    }));
                }
                else {
                    this.dispatchEvent(new events.EventQUICConnectionError({
                        detail: new errors.ErrorQUICConnectionPeer(message, {
                            data: peerError,
                        }),
                    }));
                }
                return;
            }
        }
    }
    isStreamUsed(streamId) {
        let nextId;
        const type = 0b11 & streamId;
        switch (type) {
            case 0b00:
                nextId = this.streamIdUsedClientBidi + 4;
                if (streamId <= this.streamIdUsedClientBidi ||
                    this.streamIdUsedSet.has(streamId)) {
                    return true;
                }
                else if (streamId === nextId) {
                    // Increase counter and check set in loop.
                    do {
                        this.streamIdUsedClientBidi = nextId;
                        this.streamIdUsedSet.delete(nextId);
                        nextId += 4;
                    } while (this.streamIdUsedSet.has(nextId));
                    return false;
                }
                else {
                    this.streamIdUsedSet.add(streamId);
                    return false;
                }
            case 0b01:
                nextId = this.streamIdUsedServerBidi + 4;
                if (streamId <= this.streamIdUsedServerBidi ||
                    this.streamIdUsedSet.has(streamId)) {
                    return true;
                }
                else if (streamId === nextId) {
                    // Increase counter and check set in loop.
                    do {
                        this.streamIdUsedServerBidi = nextId;
                        this.streamIdUsedSet.delete(nextId);
                        nextId += 4;
                    } while (this.streamIdUsedSet.has(nextId));
                    return false;
                }
                else {
                    this.streamIdUsedSet.add(streamId);
                    return false;
                }
            case 0b10:
                nextId = this.streamIdUsedClientUni + 4;
                if (streamId <= this.streamIdUsedClientUni ||
                    this.streamIdUsedSet.has(streamId)) {
                    return true;
                }
                else if (streamId === nextId) {
                    // Increase counter and check set in loop.
                    do {
                        this.streamIdUsedClientUni = nextId;
                        this.streamIdUsedSet.delete(nextId);
                        nextId += 4;
                    } while (this.streamIdUsedSet.has(nextId));
                    return false;
                }
                else {
                    this.streamIdUsedSet.add(streamId);
                    return false;
                }
            case 0b11:
                nextId = this.streamIdUsedServerUni + 4;
                if (streamId <= this.streamIdUsedServerUni ||
                    this.streamIdUsedSet.has(streamId)) {
                    return true;
                }
                else if (streamId === nextId) {
                    // Increase counter and check set in loop.
                    do {
                        this.streamIdUsedServerUni = nextId;
                        this.streamIdUsedSet.delete(nextId);
                        nextId += 4;
                    } while (this.streamIdUsedSet.has(nextId));
                    return false;
                }
                else {
                    this.streamIdUsedSet.add(streamId);
                    return false;
                }
            default:
                utils.never('got an unexpected ID type');
        }
    }
    processStreams() {
        for (const streamId of this.conn.readable()) {
            let quicStream = this.streamMap.get(streamId);
            if (quicStream == null) {
                if (this[StartStop_1.running] === false || this[StartStop_1.status] === 'stopping') {
                    // We should reject new connections when stopping
                    this.conn.streamShutdown(streamId, types_1.Shutdown.Write, this.reasonToCode('write', errors.ErrorQUICConnectionStopping));
                    this.conn.streamShutdown(streamId, types_1.Shutdown.Read, this.reasonToCode('read', errors.ErrorQUICConnectionStopping));
                    continue;
                }
                if (this.isStreamUsed(streamId)) {
                    utils.never('We should never repeat streamIds when creating streams');
                }
                quicStream = QUICStream_1.default.createQUICStream({
                    initiated: 'peer',
                    streamId,
                    config: this.config,
                    connection: this,
                    codeToReason: this.codeToReason,
                    reasonToCode: this.reasonToCode,
                    logger: this.logger.getChild(`${QUICStream_1.default.name} ${streamId}`),
                });
                this.streamMap.set(quicStream.streamId, quicStream);
                quicStream.addEventListener(events.EventQUICStreamSend.name, this.handleEventQUICStreamSend);
                quicStream.addEventListener(events.EventQUICStreamDestroyed.name, this.handleEventQUICStreamDestroyed, { once: true });
                quicStream.addEventListener(events_1.EventAll.name, this.handleEventQUICStream);
                this.dispatchEvent(new events.EventQUICConnectionStream({ detail: quicStream }));
            }
            quicStream.read();
        }
        for (const streamId of this.conn.writable()) {
            let quicStream = this.streamMap.get(streamId);
            if (quicStream == null) {
                if (this[StartStop_1.running] === false || this[StartStop_1.status] === 'stopping') {
                    // We should reject new connections when stopping
                    this.conn.streamShutdown(streamId, types_1.Shutdown.Write, this.reasonToCode('write', errors.ErrorQUICConnectionStopping));
                    this.conn.streamShutdown(streamId, types_1.Shutdown.Read, this.reasonToCode('read', errors.ErrorQUICConnectionStopping));
                    continue;
                }
                if (this.isStreamUsed(streamId)) {
                    try {
                        this.conn.streamSend(streamId, new Uint8Array(), false);
                    }
                    catch (e) {
                        // Both `StreamStopped()` and `FinalSize` errors means that the stream has ended and we cleaned up state
                        if (utils.isStreamStopped(e) !== false)
                            continue;
                        if (e.message === 'FinalSize')
                            continue;
                        throw e;
                    }
                    utils.never('We never expect a duplicate stream to be readable');
                }
                quicStream = QUICStream_1.default.createQUICStream({
                    initiated: 'peer',
                    streamId,
                    config: this.config,
                    connection: this,
                    codeToReason: this.codeToReason,
                    reasonToCode: this.reasonToCode,
                    logger: this.logger.getChild(`${QUICStream_1.default.name} ${streamId}`),
                });
                this.streamMap.set(quicStream.streamId, quicStream);
                quicStream.addEventListener(events.EventQUICStreamSend.name, this.handleEventQUICStreamSend);
                quicStream.addEventListener(events.EventQUICStreamDestroyed.name, this.handleEventQUICStreamDestroyed, { once: true });
                quicStream.addEventListener(events_1.EventAll.name, this.handleEventQUICStream);
                this.dispatchEvent(new events.EventQUICConnectionStream({ detail: quicStream }));
            }
            quicStream.write();
        }
    }
    /**
     * Sets up the connection timeout timer.
     *
     * This only gets called on the first `QUICConnection.send`.
     * It's the responsiblity of this timer to resolve the `closedP`.
     */
    setConnTimeoutTimer() {
        const connTimeoutHandler = async (signal) => {
            // If aborted, just immediately resolve
            if (signal.aborted)
                return;
            // This can only be called when the timeout has occurred.
            // This transitions the connection state.
            // `conn.timeout()` is time aware, so calling `conn.onTimeout` will only
            //  trigger state transitions after the time has passed.
            this.conn.onTimeout();
            // If it is closed, we can resolve, and we are done for this connection.
            if (this.conn.isClosed()) {
                this.resolveClosedP();
                // Check if the connection timed out due to the `maxIdleTimeout`
                if (this.conn.isTimedOut()) {
                    this.dispatchEvent(new events.EventQUICConnectionError({
                        detail: new errors.ErrorQUICConnectionIdleTimeout(),
                    }));
                }
                return;
            }
            await this.send();
            // Note that a `0` timeout is still a valid timeout
            const timeout = this.conn.timeout();
            // If the max idle timeout is 0, then the timeout may be `null`,
            // and it would only be set when the connection is ready to be closed.
            // If it is `null`, there is no need to setup the next timer
            if (timeout == null) {
                return;
            }
            // Allow an extra 1ms to compensate for clock desync with quiche
            this.connTimeoutTimer = new timer_1.Timer({
                delay: timeout + 1,
                handler: connTimeoutHandler,
                lazy: true,
            });
        };
        // Note that a `0` timeout is still a valid timeout
        const timeout = this.conn.timeout();
        // If this is `null`, then quiche is requesting the timer to be cleaned up
        if (timeout == null) {
            // Cancellation only matters if the timer status is `null` or settling
            // If it is `null`, then the timer handler doesn't run
            // If it is `settled`, then cancelling is a noop
            // If it is `settling`, then cancelling only prevents it at the beginning of the handler
            this.connTimeoutTimer?.cancel();
            // The `this.connTimeoutTimer` is a lazy timer, so it's status may still
            // be `null` or `settling`. So we have to delete it here to ensure that
            // the timer will be recreated.
            delete this.connTimeoutTimer;
            if (this.conn.isClosed()) {
                this.resolveClosedP();
                if (this.conn.isTimedOut()) {
                    this.dispatchEvent(new events.EventQUICConnectionError({
                        detail: new errors.ErrorQUICConnectionIdleTimeout(),
                    }));
                }
            }
            return;
        }
        // If there's no timer, create it
        // If the timer is settled, create it
        // If the timer is null, reset it
        // If the timer is settling, do nothing (it will recreate itself)
        // Plus 1 to the `timeout` to compensate for clock desync with quiche
        if (this.connTimeoutTimer == null ||
            this.connTimeoutTimer.status === 'settled') {
            this.connTimeoutTimer = new timer_1.Timer({
                delay: timeout + 1,
                handler: connTimeoutHandler,
                lazy: true,
            });
        }
        else if (this.connTimeoutTimer.status == null) {
            this.connTimeoutTimer.reset(timeout + 1);
        }
    }
    /**
     * Creates a new QUIC stream on the connection.
     */
    newStream(type = 'bidi') {
        let streamId;
        if (this.type === 'client' && type === 'bidi') {
            streamId = this.streamIdClientBidi;
        }
        else if (this.type === 'server' && type === 'bidi') {
            streamId = this.streamIdServerBidi;
        }
        else if (this.type === 'client' && type === 'uni') {
            streamId = this.streamIdClientUni;
        }
        else if (this.type === 'server' && type === 'uni') {
            streamId = this.streamIdServerUni;
        }
        if (this.isStreamUsed(streamId)) {
            utils.never('We should never repeat streamIds when creating streams');
        }
        const quicStream = QUICStream_1.default.createQUICStream({
            initiated: 'local',
            streamId: streamId,
            connection: this,
            config: this.config,
            codeToReason: this.codeToReason,
            reasonToCode: this.reasonToCode,
            logger: this.logger.getChild(`${QUICStream_1.default.name} ${streamId}`),
        });
        this.streamMap.set(quicStream.streamId, quicStream);
        quicStream.addEventListener(events.EventQUICStreamSend.name, this.handleEventQUICStreamSend);
        quicStream.addEventListener(events.EventQUICStreamDestroyed.name, this.handleEventQUICStreamDestroyed, { once: true });
        quicStream.addEventListener(events_1.EventAll.name, this.handleEventQUICStream);
        if (this.type === 'client' && type === 'bidi') {
            this.streamIdClientBidi = (this.streamIdClientBidi + 4);
        }
        else if (this.type === 'server' && type === 'bidi') {
            this.streamIdServerBidi = (this.streamIdServerBidi + 4);
        }
        else if (this.type === 'client' && type === 'uni') {
            this.streamIdClientUni = (this.streamIdClientUni + 4);
        }
        else if (this.type === 'server' && type === 'uni') {
            this.streamIdServerUni = (this.streamIdServerUni + 4);
        }
        return quicStream;
    }
    /**
     * Destroys all active streams without closing the connection.
     *
     * If there are no active streams then it will do nothing.
     * If the connection is stopped with `force: false` then this can be used
     * to force close any streams `stop` is waiting for to end.
     *
     * Destruction will occur in the background.
     */
    destroyStreams(reason) {
        for (const quicStream of this.streamMap.values()) {
            quicStream.cancel(reason);
        }
    }
    /**
     * Starts the keep alive interval timer.
     *
     * Interval time should be less than `maxIdleTimeout` unless it is `0`, which
     * means `Infinity`.
     *
     * If the `maxIdleTimeout` is `0`, this can still be useful to maintain
     * activity on the connection.
     */
    startKeepAliveIntervalTimer(ms) {
        const keepAliveHandler = async (signal) => {
            if (signal.aborted)
                return;
            // Intelligently schedule a PING frame.
            // If the connection has already sent ack-eliciting frames
            // then this is a noop.
            this.conn.sendAckEliciting();
            await this.send();
            if (signal.aborted)
                return;
            this.keepAliveIntervalTimer = new timer_1.Timer({
                delay: ms,
                handler: keepAliveHandler,
                lazy: true,
            });
        };
        this.keepAliveIntervalTimer = new timer_1.Timer({
            delay: ms,
            handler: keepAliveHandler,
            lazy: true,
        });
    }
    /**
     * Stops the keep alive interval timer
     */
    stopKeepAliveIntervalTimer() {
        this.keepAliveIntervalTimer?.cancel();
    }
};
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICConnectionNotRunning())
], QUICConnection.prototype, "connectionIdPeer", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICConnectionNotRunning())
], QUICConnection.prototype, "connectionIdShared", null);
__decorate([
    (0, decorators_1.timedCancellable)(true, config_1.minIdleTimeout, errors.ErrorQUICConnectionStartTimeout),
    __param(1, decorators_1.context)
], QUICConnection.prototype, "start", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICConnectionNotRunning(), false, [
        'starting',
        'stopping',
    ])
], QUICConnection.prototype, "recv", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICConnectionNotRunning(), false, [
        'starting',
        'stopping',
    ])
], QUICConnection.prototype, "send", null);
__decorate([
    (0, StartStop_1.ready)(new errors.ErrorQUICConnectionNotRunning())
], QUICConnection.prototype, "newStream", null);
QUICConnection = __decorate([
    (0, StartStop_1.StartStop)({
        eventStart: events.EventQUICConnectionStart,
        eventStarted: events.EventQUICConnectionStarted,
        eventStop: events.EventQUICConnectionStop,
        eventStopped: events.EventQUICConnectionStopped,
    })
], QUICConnection);
exports.default = QUICConnection;
//# sourceMappingURL=QUICConnection.js.map