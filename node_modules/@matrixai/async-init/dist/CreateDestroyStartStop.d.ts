import type { Status, Class } from './types';
import { Evented } from '@matrixai/events';
import { RWLockWriter } from '@matrixai/async-locks';
import { running, destroyed, status, statusP, initLock } from './utils';
interface CreateDestroyStartStop<StartReturn = unknown, StopReturn = unknown, DestroyReturn = unknown> extends Evented {
    get [running](): boolean;
    get [destroyed](): boolean;
    get [status](): Status;
    get [statusP](): Promise<Status>;
    readonly [initLock]: RWLockWriter;
    start(...args: Array<any>): Promise<StartReturn | void>;
    stop(...args: Array<any>): Promise<StopReturn | void>;
    destroy(...args: Array<any>): Promise<DestroyReturn | void>;
}
declare function CreateDestroyStartStop<StartReturn = unknown, StopReturn = unknown, DestroyReturn = unknown>(errorRunning?: Error, errorDestroyed?: Error, { eventStart, eventStarted, eventStop, eventStopped, eventDestroy, eventDestroyed, }?: {
    eventStart?: Class<Event>;
    eventStarted?: Class<Event>;
    eventStop?: Class<Event>;
    eventStopped?: Class<Event>;
    eventDestroy?: Class<Event>;
    eventDestroyed?: Class<Event>;
}): <T extends new (...args: any[]) => {
    start?(...args: Array<any>): Promise<StartReturn | void>;
    stop?(...args: Array<any>): Promise<StopReturn | void>;
    destroy?(...args: Array<any>): Promise<DestroyReturn | void>;
}>(constructor: T) => (new (...args: Array<any>) => CreateDestroyStartStop<StartReturn, StopReturn, DestroyReturn>) & T;
declare function ready(errorNotRunning?: Error, block?: boolean, allowedStatuses?: Array<Status>): (target: any, key: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
export { CreateDestroyStartStop, ready, running, destroyed, status, statusP, initLock, };
