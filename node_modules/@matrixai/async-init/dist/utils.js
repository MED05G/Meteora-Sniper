"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetStackTrace = exports.promise = exports.hasCaptureStackTrace = exports.AsyncGeneratorFunction = exports.GeneratorFunction = exports.AsyncFunction = exports.initLock = exports.resolveStatusP = exports.statusP = exports._statusP = exports.status = exports._status = exports.destroyed = exports._destroyed = exports.running = exports._running = void 0;
/**
 * Symbols prevents name clashes with decorated classes
 */
const _running = Symbol('_running');
exports._running = _running;
const running = Symbol('running');
exports.running = running;
const _destroyed = Symbol('_destroyed');
exports._destroyed = _destroyed;
const destroyed = Symbol('destroyed');
exports.destroyed = destroyed;
const _status = Symbol('_status');
exports._status = _status;
const status = Symbol('status');
exports.status = status;
const _statusP = Symbol('_statusP');
exports._statusP = _statusP;
const statusP = Symbol('statusP');
exports.statusP = statusP;
const resolveStatusP = Symbol('resolveStatusP');
exports.resolveStatusP = resolveStatusP;
const initLock = Symbol('initLock');
exports.initLock = initLock;
const AsyncFunction = (async () => { }).constructor;
exports.AsyncFunction = AsyncFunction;
const GeneratorFunction = function* () { }.constructor;
exports.GeneratorFunction = GeneratorFunction;
const AsyncGeneratorFunction = async function* () { }.constructor;
exports.AsyncGeneratorFunction = AsyncGeneratorFunction;
const hasCaptureStackTrace = 'captureStackTrace' in Error;
exports.hasCaptureStackTrace = hasCaptureStackTrace;
/**
 * Deconstructed promise
 */
function promise() {
    let resolveP, rejectP;
    const p = new Promise((resolve, reject) => {
        resolveP = resolve;
        rejectP = reject;
    });
    return {
        p,
        resolveP,
        rejectP,
    };
}
exports.promise = promise;
/**
 * Ready wrappers take exception objects
 * JS exception traces are created when the exception is instantiated
 * This function rewrites the stack trace according to where the wrapped
 * function is called, giving a more useful stack trace
 */
// eslint-disable-next-line @typescript-eslint/ban-types
function resetStackTrace(error, decorated) {
    if (error.stack != null) {
        const stackTitle = error.stack.slice(0, error.stack.indexOf('\n') + 1);
        if (hasCaptureStackTrace) {
            // Only available on v8
            // This will start the trace where the decorated function is called
            Error.captureStackTrace(error, decorated);
        }
        else {
            // Non-V8 systems have to do with just a normal stack
            // it is bit more noisy
            error.stack = new Error().stack ?? '';
        }
        error.stack = error.stack.replace(/[^\n]+\n/, stackTitle);
    }
}
exports.resetStackTrace = resetStackTrace;
//# sourceMappingURL=utils.js.map