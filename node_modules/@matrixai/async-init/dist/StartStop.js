"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initLock = exports.statusP = exports.status = exports.running = exports.ready = exports.StartStop = void 0;
const events_1 = require("@matrixai/events");
const async_locks_1 = require("@matrixai/async-locks");
const utils_1 = require("./utils");
Object.defineProperty(exports, "running", { enumerable: true, get: function () { return utils_1.running; } });
Object.defineProperty(exports, "status", { enumerable: true, get: function () { return utils_1.status; } });
Object.defineProperty(exports, "statusP", { enumerable: true, get: function () { return utils_1.statusP; } });
Object.defineProperty(exports, "initLock", { enumerable: true, get: function () { return utils_1.initLock; } });
const events_2 = require("./events");
const errors_1 = require("./errors");
function StartStop({ eventStart = events_2.EventAsyncInitStart, eventStarted = events_2.EventAsyncInitStarted, eventStop = events_2.EventAsyncInitStop, eventStopped = events_2.EventAsyncInitStopped, } = {}) {
    return (constructor) => {
        const { p, resolveP } = (0, utils_1.promise)();
        const constructor_ = class extends (0, events_1.Evented)()(constructor) {
            [utils_1._running] = false;
            [utils_1._status] = null;
            [utils_1._statusP] = p;
            [utils_1.resolveStatusP] = resolveP;
            [utils_1.initLock] = new async_locks_1.RWLockWriter();
            get [utils_1.running]() {
                return this[utils_1._running];
            }
            get [utils_1.status]() {
                return this[utils_1._status];
            }
            get [utils_1.statusP]() {
                return this[utils_1._statusP];
            }
            async start(...args) {
                return this[utils_1.initLock]
                    .withWriteF(async () => {
                    if (this[utils_1._running]) {
                        return;
                    }
                    this[utils_1._status] = 'starting';
                    this[utils_1.resolveStatusP]('starting');
                    const { p, resolveP } = (0, utils_1.promise)();
                    this[utils_1._statusP] = p;
                    this[utils_1.resolveStatusP] = resolveP;
                    this.dispatchEvent(new eventStart());
                    let result;
                    if (typeof super['start'] === 'function') {
                        result = await super.start(...args);
                    }
                    this[utils_1._running] = true;
                    this.dispatchEvent(new eventStarted());
                    return result;
                })
                    .finally(() => {
                    this[utils_1._status] = null;
                    this[utils_1.resolveStatusP](null);
                    const { p, resolveP } = (0, utils_1.promise)();
                    this[utils_1._statusP] = p;
                    this[utils_1.resolveStatusP] = resolveP;
                });
            }
            async stop(...args) {
                return this[utils_1.initLock]
                    .withWriteF(async () => {
                    if (!this[utils_1._running]) {
                        return;
                    }
                    this[utils_1._status] = 'stopping';
                    this[utils_1.resolveStatusP]('stopping');
                    const { p, resolveP } = (0, utils_1.promise)();
                    this[utils_1._statusP] = p;
                    this[utils_1.resolveStatusP] = resolveP;
                    this.dispatchEvent(new eventStop());
                    let result;
                    if (typeof super['stop'] === 'function') {
                        result = await super.stop(...args);
                    }
                    this[utils_1._running] = false;
                    this.dispatchEvent(new eventStopped());
                    return result;
                })
                    .finally(() => {
                    this[utils_1._status] = null;
                    this[utils_1.resolveStatusP](null);
                    const { p, resolveP } = (0, utils_1.promise)();
                    this[utils_1._statusP] = p;
                    this[utils_1.resolveStatusP] = resolveP;
                });
            }
        };
        // Preserve the name
        Object.defineProperty(constructor_, 'name', Object.getOwnPropertyDescriptor(constructor, 'name'));
        return constructor_;
    };
}
exports.StartStop = StartStop;
function ready(errorNotRunning = new errors_1.ErrorAsyncInitNotRunning(), block = false, allowedStatuses = []) {
    return (target, key, descriptor) => {
        let kind;
        if (descriptor.value != null) {
            kind = 'value';
        }
        else if (descriptor.get != null) {
            kind = 'get';
        }
        else if (descriptor.set != null) {
            kind = 'set';
        }
        const f = descriptor[kind]; // eslint-disable-line @typescript-eslint/ban-types
        if (typeof f !== 'function') {
            throw new TypeError(`${key} is not a function`);
        }
        if (f instanceof utils_1.AsyncFunction) {
            descriptor[kind] = async function (...args) {
                // If it is write locked, wait until the status has changed
                // This method may be called in between write locked and status change
                if (this[utils_1.initLock].isLocked('write') && this[utils_1._status] === null) {
                    await this[utils_1._statusP];
                }
                if (allowedStatuses.includes(this[utils_1._status])) {
                    return f.apply(this, args);
                }
                if (block) {
                    return this[utils_1.initLock].withReadF(async () => {
                        if (!this[utils_1._running]) {
                            (0, utils_1.resetStackTrace)(errorNotRunning, descriptor[kind]);
                            throw errorNotRunning;
                        }
                        return f.apply(this, args);
                    });
                }
                else {
                    if (this[utils_1.initLock].isLocked('write') || !this[utils_1._running]) {
                        (0, utils_1.resetStackTrace)(errorNotRunning, descriptor[kind]);
                        throw errorNotRunning;
                    }
                    return f.apply(this, args);
                }
            };
        }
        else if (f instanceof utils_1.GeneratorFunction) {
            descriptor[kind] = function* (...args) {
                if (allowedStatuses.includes(this[utils_1._status])) {
                    return yield* f.apply(this, args);
                }
                if ((this[utils_1.initLock].isLocked('write') && this[utils_1.status] !== null) ||
                    !this[utils_1._running]) {
                    (0, utils_1.resetStackTrace)(errorNotRunning, descriptor[kind]);
                    throw errorNotRunning;
                }
                return yield* f.apply(this, args);
            };
        }
        else if (f instanceof utils_1.AsyncGeneratorFunction) {
            descriptor[kind] = async function* (...args) {
                // If it is write locked, wait until the status has changed
                // This method may be called in between write locked and status change
                if (this[utils_1.initLock].isLocked('write') && this[utils_1._status] === null) {
                    await this[utils_1._statusP];
                }
                if (allowedStatuses.includes(this[utils_1._status])) {
                    return yield* f.apply(this, args);
                }
                if (block) {
                    return yield* this[utils_1.initLock].withReadG(() => {
                        if (!this[utils_1._running]) {
                            (0, utils_1.resetStackTrace)(errorNotRunning, descriptor[kind]);
                            throw errorNotRunning;
                        }
                        return f.apply(this, args);
                    });
                }
                else {
                    if (this[utils_1.initLock].isLocked('write') || !this[utils_1._running]) {
                        (0, utils_1.resetStackTrace)(errorNotRunning, descriptor[kind]);
                        throw errorNotRunning;
                    }
                    return yield* f.apply(this, args);
                }
            };
        }
        else {
            descriptor[kind] = function (...args) {
                if (allowedStatuses.includes(this[utils_1._status])) {
                    return f.apply(this, args);
                }
                if ((this[utils_1.initLock].isLocked('write') && this[utils_1.status] !== null) ||
                    !this[utils_1._running]) {
                    (0, utils_1.resetStackTrace)(errorNotRunning, descriptor[kind]);
                    throw errorNotRunning;
                }
                return f.apply(this, args);
            };
        }
        // Preserve the name
        Object.defineProperty(descriptor[kind], 'name', { value: key });
        return descriptor;
    };
}
exports.ready = ready;
//# sourceMappingURL=StartStop.js.map