import { RpcReturnType, RpcClientImpl } from "../../runtime/rpc";
import { Type as SubscribePacketsRequest, encodeBinary, decodeBinary } from "../../messages/block_engine/SubscribePacketsRequest";
import { Type as SubscribePacketsResponse, encodeBinary as encodeBinary_1, decodeBinary as decodeBinary_1 } from "../../messages/block_engine/SubscribePacketsResponse";
import { Type as SubscribeBundlesRequest, encodeBinary as encodeBinary_2, decodeBinary as decodeBinary_2 } from "../../messages/block_engine/SubscribeBundlesRequest";
import { Type as SubscribeBundlesResponse, encodeBinary as encodeBinary_3, decodeBinary as decodeBinary_3 } from "../../messages/block_engine/SubscribeBundlesResponse";
import { Type as BlockBuilderFeeInfoRequest, encodeBinary as encodeBinary_4, decodeBinary as decodeBinary_4 } from "../../messages/block_engine/BlockBuilderFeeInfoRequest";
import { Type as BlockBuilderFeeInfoResponse, encodeBinary as encodeBinary_5, decodeBinary as decodeBinary_5 } from "../../messages/block_engine/BlockBuilderFeeInfoResponse";
export interface Service<TReqArgs extends any[] = [], TResArgs extends any[] = []> {
    subscribePackets(request: SubscribePacketsRequest, ...args: TReqArgs): RpcReturnType<AsyncGenerator<SubscribePacketsResponse>, TResArgs>;
    subscribeBundles(request: SubscribeBundlesRequest, ...args: TReqArgs): RpcReturnType<AsyncGenerator<SubscribeBundlesResponse>, TResArgs>;
    getBlockBuilderFeeInfo(request: BlockBuilderFeeInfoRequest, ...args: TReqArgs): RpcReturnType<Promise<BlockBuilderFeeInfoResponse>, TResArgs>;
}
export declare type MethodDescriptors = typeof methodDescriptors;
export declare const methodDescriptors: {
    readonly subscribePackets: {
        readonly methodName: "SubscribePackets";
        readonly service: {
            readonly serviceName: "block_engine.BlockEngineValidator";
        };
        readonly requestStream: false;
        readonly responseStream: true;
        readonly requestType: {
            readonly serializeBinary: typeof encodeBinary;
            readonly deserializeBinary: typeof decodeBinary;
            readonly serializeJson: (value: SubscribePacketsRequest) => string;
        };
        readonly responseType: {
            readonly serializeBinary: typeof encodeBinary_1;
            readonly deserializeBinary: typeof decodeBinary_1;
            readonly serializeJson: (value: SubscribePacketsResponse) => string;
        };
    };
    readonly subscribeBundles: {
        readonly methodName: "SubscribeBundles";
        readonly service: {
            readonly serviceName: "block_engine.BlockEngineValidator";
        };
        readonly requestStream: false;
        readonly responseStream: true;
        readonly requestType: {
            readonly serializeBinary: typeof encodeBinary_2;
            readonly deserializeBinary: typeof decodeBinary_2;
            readonly serializeJson: (value: SubscribeBundlesRequest) => string;
        };
        readonly responseType: {
            readonly serializeBinary: typeof encodeBinary_3;
            readonly deserializeBinary: typeof decodeBinary_3;
            readonly serializeJson: (value: SubscribeBundlesResponse) => string;
        };
    };
    readonly getBlockBuilderFeeInfo: {
        readonly methodName: "GetBlockBuilderFeeInfo";
        readonly service: {
            readonly serviceName: "block_engine.BlockEngineValidator";
        };
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestType: {
            readonly serializeBinary: typeof encodeBinary_4;
            readonly deserializeBinary: typeof decodeBinary_4;
            readonly serializeJson: (value: BlockBuilderFeeInfoRequest) => string;
        };
        readonly responseType: {
            readonly serializeBinary: typeof encodeBinary_5;
            readonly deserializeBinary: typeof decodeBinary_5;
            readonly serializeJson: (value: BlockBuilderFeeInfoResponse) => string;
        };
    };
};
export declare class RpcError<TTrailer = any> extends Error {
    trailer: TTrailer;
    constructor(trailer: TTrailer);
}
export interface CreateServiceClientConfig {
    responseOnly?: boolean;
    devtools?: true | {
        tags: string[];
    };
}
export declare function createServiceClient<TMetadata, THeader, TTrailer>(rpcClientImpl: RpcClientImpl<TMetadata, THeader, TTrailer>, config?: undefined): Service<[] | [TMetadata], []>;
export declare function createServiceClient<TMetadata, THeader, TTrailer>(rpcClientImpl: RpcClientImpl<TMetadata, THeader, TTrailer>, config: CreateServiceClientConfig & {
    responseOnly: false;
}): Service<[] | [TMetadata], [THeader, Promise<TTrailer>]>;
export declare function createServiceClient<TMetadata, THeader, TTrailer>(rpcClientImpl: RpcClientImpl<TMetadata, THeader, TTrailer>, config: CreateServiceClientConfig & {
    responseOnly?: true;
}): Service<[] | [TMetadata], []>;
//# sourceMappingURL=BlockEngineValidator.d.ts.map