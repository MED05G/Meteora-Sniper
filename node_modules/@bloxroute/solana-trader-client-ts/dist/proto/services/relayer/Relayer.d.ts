import { RpcReturnType, RpcClientImpl } from "../../runtime/rpc";
import { Type as GetTpuConfigsRequest, encodeBinary, decodeBinary } from "../../messages/relayer/GetTpuConfigsRequest";
import { Type as GetTpuConfigsResponse, encodeBinary as encodeBinary_1, decodeBinary as decodeBinary_1 } from "../../messages/relayer/GetTpuConfigsResponse";
import { Type as SubscribePacketsRequest, encodeBinary as encodeBinary_2, decodeBinary as decodeBinary_2 } from "../../messages/relayer/SubscribePacketsRequest";
import { Type as SubscribePacketsResponse, encodeBinary as encodeBinary_3, decodeBinary as decodeBinary_3 } from "../../messages/relayer/SubscribePacketsResponse";
export interface Service<TReqArgs extends any[] = [], TResArgs extends any[] = []> {
    getTpuConfigs(request: GetTpuConfigsRequest, ...args: TReqArgs): RpcReturnType<Promise<GetTpuConfigsResponse>, TResArgs>;
    subscribePackets(request: SubscribePacketsRequest, ...args: TReqArgs): RpcReturnType<AsyncGenerator<SubscribePacketsResponse>, TResArgs>;
}
export declare type MethodDescriptors = typeof methodDescriptors;
export declare const methodDescriptors: {
    readonly getTpuConfigs: {
        readonly methodName: "GetTpuConfigs";
        readonly service: {
            readonly serviceName: "relayer.Relayer";
        };
        readonly requestStream: false;
        readonly responseStream: false;
        readonly requestType: {
            readonly serializeBinary: typeof encodeBinary;
            readonly deserializeBinary: typeof decodeBinary;
            readonly serializeJson: (value: GetTpuConfigsRequest) => string;
        };
        readonly responseType: {
            readonly serializeBinary: typeof encodeBinary_1;
            readonly deserializeBinary: typeof decodeBinary_1;
            readonly serializeJson: (value: GetTpuConfigsResponse) => string;
        };
    };
    readonly subscribePackets: {
        readonly methodName: "SubscribePackets";
        readonly service: {
            readonly serviceName: "relayer.Relayer";
        };
        readonly requestStream: false;
        readonly responseStream: true;
        readonly requestType: {
            readonly serializeBinary: typeof encodeBinary_2;
            readonly deserializeBinary: typeof decodeBinary_2;
            readonly serializeJson: (value: SubscribePacketsRequest) => string;
        };
        readonly responseType: {
            readonly serializeBinary: typeof encodeBinary_3;
            readonly deserializeBinary: typeof decodeBinary_3;
            readonly serializeJson: (value: SubscribePacketsResponse) => string;
        };
    };
};
export declare class RpcError<TTrailer = any> extends Error {
    trailer: TTrailer;
    constructor(trailer: TTrailer);
}
export interface CreateServiceClientConfig {
    responseOnly?: boolean;
    devtools?: true | {
        tags: string[];
    };
}
export declare function createServiceClient<TMetadata, THeader, TTrailer>(rpcClientImpl: RpcClientImpl<TMetadata, THeader, TTrailer>, config?: undefined): Service<[] | [TMetadata], []>;
export declare function createServiceClient<TMetadata, THeader, TTrailer>(rpcClientImpl: RpcClientImpl<TMetadata, THeader, TTrailer>, config: CreateServiceClientConfig & {
    responseOnly: false;
}): Service<[] | [TMetadata], [THeader, Promise<TTrailer>]>;
export declare function createServiceClient<TMetadata, THeader, TTrailer>(rpcClientImpl: RpcClientImpl<TMetadata, THeader, TTrailer>, config: CreateServiceClientConfig & {
    responseOnly?: true;
}): Service<[] | [TMetadata], []>;
//# sourceMappingURL=Relayer.d.ts.map