"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGrpcClientImpl = exports.createGrpcJsClient = exports.Status = void 0;
const event_buffer_1 = require("@pbkit/runtime/async/event-buffer");
const observer_1 = require("@pbkit/runtime/async/observer");
const grpc = require("@grpc/grpc-js");
var Status;
(function (Status) {
    Status["OK"] = "0";
    Status["CANCELLED"] = "1";
    Status["UNKNOWN"] = "2";
    Status["INVALID_ARGUMENT"] = "3";
    Status["DEADLINE_EXCEEDED"] = "4";
    Status["NOT_FOUND"] = "5";
    Status["ALREADY_EXISTS"] = "6";
    Status["PERMISSION_DENIED"] = "7";
    Status["RESOURCE_EXHAUSTED"] = "8";
    Status["FAILED_PRECONDITION"] = "9";
    Status["ABORTED"] = "10";
    Status["OUT_OF_RANGE"] = "11";
    Status["UNIMPLEMENTED"] = "12";
    Status["INTERNAL"] = "13";
    Status["UNAVAILABLE"] = "14";
    Status["DATA_LOSS"] = "15";
    Status["UNAUTHENTICATED"] = "16";
})(Status = exports.Status || (exports.Status = {}));
function createGrpcJsClient(host, credentials = grpc.credentials.createInsecure()) {
    return new grpc.Client(host, credentials);
}
exports.createGrpcJsClient = createGrpcJsClient;
function createGrpcClientImpl(config) {
    const grpcJsClient = config.grpcJsClient;
    return (methodDescriptor) => {
        const { responseStream, requestType, responseType, service: { serviceName }, methodName, } = methodDescriptor;
        const path = `/${serviceName}/${methodName}`;
        const isServerStreamOrBidi = responseStream;
        const trailerWhenDrainEnded = Object.freeze({
            status: Status.CANCELLED,
            statusMessage: "Drain ended",
        });
        return (req, metadata) => {
            const headerPromise = (0, observer_1.defer)();
            const trailerPromise = (0, observer_1.defer)();
            let call;
            const eventBuffer = (0, event_buffer_1.createEventBuffer)({
                onDrainEnd: isServerStreamOrBidi
                    ? () => {
                        call.cancel();
                        call.end();
                        headerPromise.reject("Drain ended before receive header");
                        trailerPromise.resolve(trailerWhenDrainEnded);
                    }
                    : undefined,
            });
            (async () => {
                const m = { ...metadata };
                if (config.metadata) {
                    for (const [key, value] of Object.entries(config.metadata)) {
                        if (key in m)
                            continue;
                        const v = typeof value === "string" ? value : await value();
                        if (v)
                            m[key] = v;
                    }
                }
                const grpcMetadata = new grpc.Metadata();
                for (const [key, value] of Object.entries(m)) {
                    grpcMetadata.set(key, value);
                }
                call = grpcJsClient.makeBidiStreamRequest(path, (req) => Buffer.from(requestType.serializeBinary(req)), responseType.deserializeBinary, grpcMetadata);
                call.on("metadata", (header) => {
                    headerPromise.resolve(grpcMetadataToRecord(header));
                });
                call.on("data", eventBuffer.push);
                call.on("error", (error) => {
                    eventBuffer.error(error);
                    trailerPromise.resolve({
                        status: Status.UNKNOWN,
                        statusMessage: error.message,
                    });
                });
                call.on("status", ({ code, details, metadata }) => {
                    trailerPromise.resolve({
                        ...grpcMetadataToRecord(metadata),
                        status: String(code),
                        statusMessage: details,
                    });
                });
                call.on("end", eventBuffer.finish);
                for await (const value of req) {
                    call.write(value);
                }
                call.end();
            })();
            return [eventBuffer.drain(), headerPromise, trailerPromise];
        };
    };
}
exports.createGrpcClientImpl = createGrpcClientImpl;
function grpcMetadataToRecord(value) {
    const result = {};
    const map = value?.getMap() ?? {};
    for (const key in map) {
        const value = map[key];
        result[key] = value instanceof Buffer ? value.toString("utf8") : value;
    }
    return result;
}
